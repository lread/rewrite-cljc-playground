= Merging rewrite-clj and rewrite-cljs
:toc:
:toclevels: 6

== Introduction
Rewrite-cljc is a merge of https://github.com/xsc/rewrite-clj[rewrite-clj] and https://github.com/clj-commons/rewrite-cljs[rewrite-cljs] giving us a one stop rewrite-cljc shop for Clojure and ClojureScript developers.

== Goals
1. *Minimize API breakage*. Within reason, maintain API compatability with both rewrite-clj and rewrite-cljs. I'd like rewrite-cljc to be an low friction replacement for `rundis/rewrite-cljs` (actually now living at `clj-commons/rewrite-cljs`) and `xsc/rewrite-clj`.
2. *Feature parity*. Rewrite-cljs has lagged behind rewrite-cljc. Bring rewrite-cljs up to parity with rewrite-cljc. Bring any rewrite-cljs specific features over to rewrite-cljc.
3. *Preserve type hints*. I will respect and carry over existing type hinting in rewrite-clj and rewrite-cljs. I will not, at this time, evaluate if existing type hinting has value.
4. *Improve documentation*. I think that rewrite-clj documentation is good, but as I dig deeper into using the library and get feedback on Slack, I see places where guidance could be improved.
5. *Document design decisions*. I'm not sure what form this will take, but I do like projects that include histories of architectural and design decisions. Perhaps I'll adopt https://github.com/cljdoc/cljdoc/tree/master/doc/adr[adr ala cljdoc]. For now you can think of this document as I kind of sloppy-mega adr for my merge work.
6. *Modernize/update test/build*. Look at what is available today and make a choice.
7. *Define library version scheme*. Evaluate options, pick one and document.
8. *Find home for this work*. Ideally, I think this work would be merged into `xsc/rewrite-clj`, but if that does not work out, a reasonable alternative might be `clj-commons/rewrite-cljc` (which would be a replacement for a deprecated `clj-commons\rewrite-cljs`)

== Strategic Compromises
1. *Favor single code base*. I will favor a single code base over maintaining  http://rundis.github.io/blog/2015/clojurescript_performance_tuning.html[ClojureScript specific optimizations from rewrite-cljs]. These can be brought in at a later date if needed.
2. *Use generic exceptions*.  This is technically an API breakage, but I will switch to using the Clojure/ClojureScript agnostic `ex-info` for exceptions.
3. *Favor rewrite-clj features when there is overlap*. I currently only see one feature that overlaps between the two projects. rewrite-clj and rewrite-cljs both have positional (row/col) support. Base positional support in rewrite-clj is full featured and updates with any changes made, so we'll use it instead of rewrite-cljs's more primitive tools reader based positional support. This technically constitutes an API breakage for rewrite-cljs. We will, though, carry over rewrite-cljs's higher level positional functions.

== Changes
=== Breaking
. Root namespace is `rewrite-cljc` instead of `rewrite-clj`
. Reader generated location metadata on coercion is now elided by default. +
Bind `rewrite-cljc.node/\*elide-metadata*` to `nil` for rewrite-clj behavior.
. Minimum versions
** Clojure v1.9
** Java v1.8
** ClojureScript v10
. Now using `ex-info` for exceptions
. Base positional support for rewrite-cljs has been migrated over to rewrite-clj implementation

=== Potentially breaking
1. Switched to `clojure.tools.reader.edn`
2. Potential performance hit for rewrite-cljs. Some rewrite-cljs specific optimizations dropped in favor of single code base.

=== Neutral
1. Docs now generated by cljdoc
** direct zipper functions (`right*`, `left*`, `up*`, etc) now show correct arguments.
** ``import-var``ed protocol functions now point to correct source code
** now using asciidoc
** now using markdown in docstrings
2. Continuous integration is now handled via GitHub Actions and adds testing
** on macOS and Windows operating systems
** for a GraalVM natively compiled rewrite-cljc
3. Test tooling now uses:
** figwheel main for development cljs testing
** kaocha for clj testing
4. Switched from leiningen to tools cli `deps.edn`

=== Accretive

From what I perceive as public APIs, rewrite-clj has gained:

[cols="3,1,3"]
|===
| public | origin | description

| rewrite-cljc.node/\*elide-metadata*
| new
| metadata to omit, used by form-meta and coercion

| rewrite-cljc.node/form-meta
| new
| same as clojure core meta but omits reader generated metadata

| rewrite-cljc.node/node?
| new
| returns true if element is a rewrite-cljc created node

| rewrite-cljc.paredit
| rewrite-cljs
| API for structured editing of S-expression data

| rewrite-cljc.zip/append-child*
| internal
| accidental omission from public API

| rewrite-cljc.zip/find-last-by-pos
| rewrite-cljs
| positional search support

| rewrite-cljc.zip/find-tag-by-pos
| rewrite-cljs
| positional search support

| rewrite-cljc.zip/insert-newline-left
| internal
| accidental omission from public API

| rewrite-cljc.zip/insert-newline-right
| internal
| accidental omission from public API

| rewrite-cljc.zip/insert-space-left
| internal
| accidental omission from public API

| rewrite-cljc.zip/insert-space-right
| internal
| accidental omission from public API

| rewrite-cljc.zip/position-span
| rewrite-cljs
| positional search support

| rewrite-cljc.zip/remove-preserve-newline
| rewrite-cljs
| same as remove but preserves newlines

| rewrite-cljc.zip/subzip
| internal
| operate on a sub tree without affecting location
|===

And rewrite-cljs has gained all of rewrite-clj's features except for the ability to read from files.

=== Detailed API diffs

I've used https://github.com/lread/diff-apis[diff-apis] to compare apis.
Normally I would have excluded any apis tagged with `:no-doc` metadata, but
because many folks used undocumented features in rewrite-clj and rewrite-cljs, I
have done a complete comparison of all publics - except where noted . Each
report contains some observations under the "Notes" header.

* link:../generated/api-diffs/rewrite-clj-and-rewrite-cljs.adoc[rewrite-clj vs rewrite-cljs] API differences between the projects on which rewrite-cljc is based.
* link:../generated/api-diffs/rewrite-clj-and-rewrite-cljc-clj.adoc[rewrite-clj vs rewrite-cljc] how different is rewrite-cljc from rewrite-clj?
* link:../generated/api-diffs/rewrite-cljs-and-rewrite-cljc-cljs.adoc[rewrite-cljs vs rewrite-cljc] how different is rewrite-cljc from rewrite-cljs?
* link:../generated/api-diffs/rewrite-cljc.adoc[rewrite-cljc] a look at how cljs and clj sides of rewrite-cljc differ
* link:../generated/api-diffs/rewrite-cljc-documented-only.adoc[rewrite-cljc documented apis only] a look at how cljs and clj sides of rewrite-cljc differ for documented apis.

=== Feature Differences
No ability to read from files when using rewrite-cljc from ClojureScript.

== Root namespace of `rewrite-cljc`

Both rewrite-clj and rewite-cljs share the same root namespace of `rewrite-clj`.

I decided against reusing the same root namespace for rewrite-cljc. It will have
`rewrite-cljc` as its root namespace.

Rationale:

* Ideally rewrite-cljc work would have been merged into the current rewrite-clj
repo, but that did not work out, so rewrite-cljc will have different maven
coordinates than rewrite-clj, most likely `clj-commons/rewrite-cljc`.

* Having to update namespace `:require` references from `rewrite-clj` to `rewrite-cljc`
in one's project sources to upgrade to rewrite-cljc is much less of a burden than
the burden of the confusion of introducing colliding namespaces to the Clojure
community.
+
Colliding namespaces would likely first confuse, then require exclusions -
a deps.edn example:
+
[source,clojure]
----
{olical/depot {:mvn/version "1.8.4" :exclusions [rewrite-clj/rewrite-clj]}}
----

* A different root namespace means upgrading to rewrite-cljc will be a
clear and deliberate choice.

== Projects Using rewrite-clj and/or rewrite-cljs
I've tried to make note of popular/active projects that make use of rewrite-clj and rewrite-cljs. I've linked where I've explicitly verified a migration to rewrite-cljc.

[cols="15%,20%,20%,15%,30%"]
|===
| Project | rewrite&#8209;clj? | rewrite&#8209;cljs? | Migration Verification | Notes

| https://github.com/mauricioszabo/atom-chlorine[chlorine]
| no
| yes
| -
| REPL support for Atom editor

| https://github.com/borkdude/clj-kondo[clj-kondo]
| custom version
| no
| -
| uses an internal custom version of rewrite-clj

| https://github.com/weavejester/cljfmt[cljfmt]
| yes
| yes
| https://github.com/lread/cljfmt/commits/lread-rewrite-cljc-test[fork]
| source code formatter

| https://github.com/greglook/cljstyle[cljstyle]
| yes
| no
| -
| source code formatter based on cljfmt

| https://github.com/snoe/clojure-lsp[clojure-lsp]
| yes
| no
| https://github.com/lread/clojure-lsp/commits/lread-rewrite-cljc-test[fork]
| language server for Clojure

| https://github.com/Olical/depot[depot]
| yes
| no
| -
| find newer versions of your deps.edn dependencies

| https://github.com/jonase/kibit[kibit]
| yes
| no
| -
| Finds non-idiomatic Clojure code

| https://github.com/xsc/lein-ancient[lein-ancient]
| yes
| no
| -
| find newer versions of your lein dependencies

| https://github.com/benedekfazekas/mranderson[MrAnderson]
| yes
| no
| -
| Dependency inliner

| https://github.com/jstepien/mutant[mutant]
| yes
| no
| -
| Source code mutator

| https://github.com/juxt/pack.alpha[pack (alpha)]
| yes
| no
| -
| Clojure project packager

| https://github.com/bhauman/rebel-readline[rebel-readline]
| indirectly via cljfmt
| no
| -
| smart editing at at the REPL terminal, optionally used in conjunction with https://github.com/bhauman/figwheel-main[figwheel-main]

| https://github.com/cognitect-labs/REBL-distro[REBL]
| indirectly via cljfmt
| no
| -
| graphical interactive tool for browsing Clojure data

| https://github.com/clojure-emacs/refactor-nrepl[refactor-nrepl]
| yes
| no
| https://github.com/lread/refactor-nrepl/commits/lread-rewrite-cljc-test[fork]
| refactoring support used in conjunction with https://github.com/clojure-emacs/cider[cider]

| https://github.com/mauricioszabo/repl-tooling[repl-tooling]
| no
| yes
| -
| base package for Clojure editor tooling. Interesting: uses rewrite-clj.reader directly.

| https://github.com/atomist-skills/update-leiningen-dependencies-skill[update-leiningen-dependencies-skill]
| no
| yes
| https://github.com/lread/update-leiningen-dependencies-skill/commits/lread-rewrite-cljc-test[fork]
| dependency version tracker, great for a migration test of a project that uses shadow-cljs

| https://github.com/kkinnear/zprint[zprint]
| yes
| yes
| https://github.com/lread/zprint/commits/lread-rewrite-cljc-test[fork]
| source code formatter

|===

== Projects Using rewrite-cljc
We have one early adopter!: https://github.com/borkdude/carve[carve]

== Tooling

=== Build tools
I have moved from leiningen to tools cli and `deps.edn`. Like everything, this change has pros and cons. Overall, I like the simplicity and control it brings. Babashka scripts take the place of lein aliases where I can have the build do exactly what I want it to. One current, but likely temporary, downside is the jar and deploy support for tools cli is fragmented with many young libraries. I have opted, for now to employ the tried and true maven for jar and deploy.

=== Continuous integration
The future of https://travis-ci.org/[Travis CI] looked a bit tenuous when I started this work.
I initially switched over to https://circleci.com/[CircleCI], but then when GitHub Actions became available decided it was a better fit:

* in addition to Linux, offers macOS and Windows testing in its free tier
* 7gb of RAM satisfies GraalVM's memory hungry `native-image`

=== Testing and linting tools
After looking around, I settled on the following for continuous integration:

. https://github.com/lambdaisland/kaocha[Kaocha] for running Clojure unit tests.
. moved from lein-doo to https://github.com/Olical/cljs-test-runner[cljs-test-runner] (which still uses https://github.com/bensu/doo[doo] under the hood) for running ClojureScript unit tests under node and chrome headless. I considered Koacha's cljs support and will reconsider when it matures a bit.
. I fail the build when a lint with https://github.com/borkdude/clj-kondo[clj-kondo] produces any warnings and/or errors.

During development, I found the following helpful:

. kaocha in watch mode for Clojure
. figwheel main for ClojureScript

== General Decisions

=== * Library version scheme - [red]*in progress*
I see plenty of version scheme variations out there these days. Here are a few examples I find interesting:

[cols="10,40,20,~",options="header"]
|====
|Project
|Scheme
|Example
|Observation

|https://github.com/clojure/clojurescript/releases[ClojureScript]
|major.minor.<commit count since major.minor>
|`1.10.520`
|Tracks Clojure version.

|https://github.com/borkdude/clj-kondo/releases[clj-kondo]
|yyyy-mm-dd-qualifier
|`2019.07.05-alpha`
|Freshness built into version.

|https://github.com/cljdoc/cljdoc[cljdoc]
|major.minor.<commit count>-<short git sha>
|`0.0.1315-c9e9a73`
|The short-sha safeguards against any potential confusion with duplicate commit counts for builds on different machines.

|https://github.com/noprompt/meander[meander]
|meander/<release> 0.0.<commit count>
|`meander/delta` `0.0.137`
|This scheme changes the artifact-id (for example gamma to delta) every time a potentially breaking change is introduced effectively releasing a new product for every breaking change.

|https://github.com/clojure/spec.alpha[spec.alpha]
|unimportant
|unimportant
|The alpha state is burnt into the project name and library namespace.
|====

rewrite-clj is not a new project. I feel the version should reflect at least some familiarity with its current scheme.

As of this writing the current version of rewrite-clj is `0.6.1`. I am guessing that the 0 is an unused version element, and we have a `0.major.minor` scheme.

rewrite-cljc is going to switch to a ClojureScript-ish scheme. +
It will use a `major.minor.<commit count since major.minor>-<qualifier>` scheme. +
Our first version will be `1.0.42-alpha` where `42` is just a wild guess right now.

An small awkwardness with this scheme is the change log. The change log should be part of the release
but it does reference a git commit count. This, I suppose will be addressed locally with amended
commits.

=== * Release Strategy - [red]*in progress*

TODO: think about the following...

We'll opt not to make SNAPSHOT releases and assume the community is good with testing pre-releases via
github coordinates. That said, I suppose opting out of SNAPSHOT releases means option out of testing
our release flow on successful pushes.

Our releases notes will be managed under GitHub releases.  I'll have a look at how @borkdude does this for his
various projects.

Not sure about release cadence yet. I expect to cut a release when I feel a pre-release has been tested enough.

TODO: Consider some sort of canary testing for a set of projects that make use of rewrite-clj. Examples that
come to mind: cljfmt, zprint, carve.

=== Source directory layout
When I first started to experiment with a cljc version of rewrite-clj, my directory layout looked like:

----
src/
  clj/
    rewrite-cljc/
  cljs/
    rewrite-cljc/
  cljc/
    rewrite-cljc/
test/
  clj/
    rewrite-cljc/
  cljs/
    rewrite-cljc/
  cljc/
    rewrite-cljc/
----

After a certain amount of work, I realized the majority of the code was cljc so opted for the much simpler:

----
src/
  rewrite-cljc/
test/
  rewrite-cljc/
----

===  Graalvm Support

Some command line tools written in Clojure are using Graal to compile to native
executables for fast startup times.

Others have done the work to test that rewrite-clj can be compiled with Graal.
There is benefit to the community to test that rewrite-cljc can also be compiled
to native code with Graal.

Noticing that there were differing approaches Graalifying Clojure, none of them centrally
documented, @borkdude and I created https://github.com/lread/clj-graal-docs[clj-graal-docs]
to develop and share scripts and tips.

My goal is to run the rewrite-cljc test suite from a graalvm native image to
give some confidence that rewrite-cljc works after compiled with Graal.

=== Technical Issues

. Windows tooling requirements. Setup for running GraalVM jdk8 on Windows relies on old Microsoft tooling making setup
challenging.
. RAM requirements. GraalVM's `native-image` which creates the target executable, can consume a significant
amount of RAM.

==== Windows Tooling Requirements
I've decided that, for now, figuring out how to setup the proper tooling for Windows for GraalVM jdk8 is not worth my effort.
We'll continue to test on Windows but only for GraalVM jdk11.

==== Ram Requirements
I spent quite a bit of time trying to figure out how to overcome the RAM limitations of free tiers of continuous
integration services. Drone Cloud is the most generous with 64gb of RAM available but only supports Linux. CircleCI
offers 3.5gb of RAM and is also Linux only in its free tier. GitHub Actions, offers 7gb of RAM and offers
macOS, Linux and Windows.

I seriously explored two approaches:

. natively compile tests and library
. interpret tests via sci over natively compile library

If I had applied https://github.com/lread/clj-graal-docs#native-image-compilation-time[Clojure direct linking]
earlier in my tests, I might have stopped at the first approach. For me, direct linking made approach 1 viable.

For now, I am testing using both approaches. Overviews can be found at
https://github.com/lread/clj-graal-docs/blob/master/doc/testing-strategies.md[clj-graal-doc's testing strategies page].


== Questionable Decisions

=== Allowing garden style keywords

Borkdude is kind enough to ping me when there are issues with the internally
forked version of rewrite-clj he uses for clj-kondo. It turns out that
clojure.tools.reader.edn does not parse https://github.com/noprompt/garden[garden-style]
keywords such as `:&::before`. The reader sees a double colon as illegal if it is anywhere in the keyword.
Borkdude overcame this limitation by allowing a keyword to contain embedded
double colons via a customized version of ``clojure.tools.reader.edn``'s
`read-keyword` function.

I transcribed his work to rewrite-cljc.

The maintenance cost to hacking a 3rd party lib is that upgrades will have to be
carefully tracked. That said, we do have a good suite of tests that should
uncover any issues.

=== Not allowing symbols with multiple slashes

While clojure reads `'org/clojure/math.numeric-tower`, `clojure.tools.reader.edn`
barfs on this and therefore rewrite-cljc does as well.

It has been documented as illegal for a symbol to have more than one `/`.

I have opted to not, at this time, adapt rewrite-cljc to allow parsing of this
illegal syntax. This might seem a bit hypocritical because I did, some time ago, innocently
https://github.com/borkdude/clj-kondo/issues/378[raise an issue on clj-kondo for
this].

== Clojure/ClojureScript Issues

=== ClojureScript namespace clashes
ClojureScript uses Google Closure under the hood. Because of the way Google Closure handles namespaces, some namespaces that work fine on Clojure clash under ClojureScript. Some rewrite-clj namespaces clash for ClojureScript, for example:

* `rewrite-clj.zip/find`
* `rewrite-clj.zip.find`

The original rewrite-cljs author worked around this problem by renaming namespaces to avoid the clashes.

[%autowidth]
|===

.2+h|library .2+h|namespace 3+h|in rewrite-cljc
h|namespace h|clj? h|cljs?

|rewrite-clj
|rewrite-clj.node.coerce
|rewrite-cljc.node.coerce
|yes
|no

|rewrite-cljs
|rewrite-clj.node.coerce[yellow-background]**r**
|rewrite-cljc.node.coercer
|yes
|yes

|rewrite-clj
|rewrite-clj.node.string
|rewrite-cljc.node.string
|yes
|no

|rewrite-cljs
|rewrite-clj.node.string[yellow-background]**z**
|rewrite-cljc.node.stringz
|yes
|yes

|rewrite-clj
|rewrite-clj.zip.edit
|rewrite-cljc.zip.edit
|yes
|no

|rewrite-cljs
|rewrite-clj.zip.edit[yellow-background]**z**
|rewrite-cljc.zip.editz
|yes
|yes

|rewrite-clj
|rewrite-clj.zip.find
|rewrite-cljc.zip.find
|yes
|no

|rewrite-cljs
|rewrite-clj.zip.find[yellow-background]**z**
|rewrite-cljc.zip.findz
|yes
|yes

|rewrite-clj
|rewrite-clj.zip.remove
|rewrite-cljc.zip.remove
|yes
|no

|rewrite-cljs
|rewrite-clj.zip.remove[yellow-background]**z**
|rewrite-cljc.zip.removez
|yes
|yes

|rewrite-clj
|rewrite-clj.zip.seq
|rewrite-cljc.zip.seq
|yes
|no

|rewrite-cljs
|rewrite-clj.zip.seq[yellow-background]**z**
|rewrite-cljc.zip.seqz
|yes
|yes
|===

None of these namespaces are part of public APIs, but because I see a lot of
code that uses these internal namespaces, I decided to preserve the existing
rewrite-clj and rewrite-cljs naming for rewrite-cljc.

=== Clojure/ClojureScript interop

* Where I felt I could get away with it, I localized Clojure/ClojureScript differences in the `rewrite-cljc.interop` namespace.
* Although technically an API breakage, I made a choice to switch all rewrite-cljc thrown exceptions to the Clojure/ClojureScript compatible ex-info.
* Some notes on differences between Clojure and ClojureScript
** throws and catches, if not using ex-info are different
** namespace requires cannot use shorthand syntax in cljs
** macros must (sometimes) be included differently
** IMetaData and other base types different
** format not part of cljs standard lib
** no Character in cljs
** no ratios in cljs
** testing for NaN is different
** different max numerics


== Rewrite-clj/cljs Analysis

=== What is the public API?
rewrite-clj purposefully only generated documentation for specific namespaces. It is reasonable to assume that these namespaces represent the public API.

* `rewrite-clj.parse`
* `rewrite-clj.node`
* `rewrite-clj.zip`

I am not sure why `rewrite-clj.custom-zipper` is included in the documented public API, because its functionality is exposed through `rewrite-clj.zip`, I expect this was perhaps an oversight, but might be wrong.

Because what is public versus what is private was not stressed strongly in the
rewrite-clj README, I frequently see private APIs used in code. For this reason,
I've worked, within reason, not to break what I understand to be private APIs.

=== S-expressions
rewrite-clj allows parsed Clojure/ClojureScript/EDN to be converted back and forth to s-expressions.  Example from a REPL session:

[source,clojure]
----
user=> (require '[rewrite-cljc.zip :as z])
nil
user=> (def zipper (z/of-string "[1 2 3]"))  // <1>
#'user/zipper
user=> zipper
[<vector: [1 2 3]> {:l [], :pnodes [<forms: [1 2 3]>], :ppath nil, :r nil}]
user=> (def s (z/sexpr zipper)) // <2>
#'user/s
user=> s
[1 2 3]
user=> (require '[rewrite-cljc.node :as n])
nil
user=> (n/coerce s) // <3>
<vector: [1 2 3]>
----
<1> parse string to rewrite-clj nodes and create zipper
<2> convert rewrite-clj node at current location in zipper to s-expression
<3> convert s-expression to rewrite-clj node

While I expect this can be quite convenient, it does come with caveats:

1. What happens when we try to `sexpr` Clojure specific features from ClojureScript? For example, ratios are available in Clojure but not ClojureScript.
2. If you try to `sexpr` something that cannot be converted into an s-epxression an exception will be thrown.

My guidance is use `sexpr` in only in specific cases, where you know ahead of time what you are parsing. General blind use of `sexpr` is not recommended.

For rewrite-cljc itself, I have removed internal problematic uses of `sepxr`.

=== Which reader?
rewrite-clj makes use of Clojure's reader.  There are a few choices though:

1. `clojure.tools.reader`
2. `clojure.tools.reader.edn`
3. `clojure.reader`
4. `clojure/reader-string`

As I understand it, `clojure.tools.reader.edn` is the safest choice and I have updated rewrite-cljc to use it in all cases.


=== Potemkin import-vars
rewrite-clj makes use of a slightly modified version of https://github.com/ztellman/potemkin#import-vars[Potemkin import-vars]. The intent of import-vars is to make it easy to expose a public API from a set of internal namespaces.

When I first reviewed its usage in rewrite-clj, I found import-vars to be quite elegant. I have since learned that there is quite a bit of strong opinion in the Clojure community surrounding import-vars. Not all of it is rosy.

Also, there is no ClojureScript version of import-vars.

That said, I decided, at least for now, to honor the original rewrite-clj
codebase and carry on with it. To be honest, this gave me the (the apparently
too tempting to resist) opportunity to learn how to write a version of
import-vars for ClojureScript. This led me to discover that while cljdoc did
cope fine with import-vars trickery for Clojure code, it did not have any
support for it for ClojureScript code. I made the necessary changes to cljdoc's
fork of codox and subsequently cljdoc-analyzer. When Martin Klepsch finds the
time, he will integrate my pull request.

I also extended import-vars to rewrite-clj's purposes by adding a facility to
rename imported vars and adapt docstrings.

All is not entirely rainbows and unicorns yet,

. I am not certain, but I think import-vars might not play well with https://github.com/cloverage/cloverage[cloverage]. I gave it a quick try and it failed miserably. My first suspect is import-vars.
. Linters can report false posistives
.. https://github.com/candid82/joker[joker] has no concept of import-vars
.. https://github.com/borkdude/clj-kondo[clj-kondo] does understand import-vars - but not my customized version that handles transformations of symbols.

=== Positional support
rewrite-clj

1. added a custom zipper to optionally track row/col within Clojure/ClojureScript/EDN files.
2. expresses positions as a `[row-number col-number]` vector.

rewrite-cljs

1. made use of the positional support provided by Clojure tools reader.
2. exposed a couple of functions to search by position.
3. expressed positions as a `{:row row-number :col col-number}` map

Because the positional support in rewrite-clj tracks row/col even after zipper modifications, we use it instead of rewrite-cljs's implementation.
We:

1. continue to support both rewrite-clj vector rewrite-cljs map notations for positions on function parameters.
2. use vector notation for position on function returns. I personally prefer the map notation, but, as a rule, favor rewrite-clj over rewrite-cljs because rewrite-clj is the more widely used library and thus changes affect more users.
3. include rewrite-cljs's positional functions: `rewrite-cljc.zip/find-last-by-pos` and `rewrite-cljc.zip/find-tag-by-pos` .

The most glaring breaking change for ClojureScript is that it must now create the zipper with positional support enabled, for example: `(z/of-string "[1 2 3]" {:track-position true})`

=== * Namespaced maps and keywords - [red]*in progress*

==== Nomenclature
To be clear about what we are discussing in this section, I'll define some terms.

*Namespaced Elements* +
Clojure docs describe namespaced elements but I did not see clear nomenclature defined.
Alex Miller helped out on Slack, I will use:

|===
| term | shorthand | keyword example | map example

| _unqualified_
|
a| `:foo`
a| `{:x 10}`

| _literally qualified_ +

Alex called this variant "qualified", I've added "literally" to distinguish it from its "auto-resolved" cousins
 |
a| `:prefix-ns/foo`
a| `#:prefix-ns{:a 1}`

| _auto-resolved current namespace qualified_
| _current-ns qualified_
a| `::foo`
a| `#::{:b 2}`

| _auto-resolved alias namespace qualified_
| _alias-ns qualified_
a| `::ns-alias/foo`
a| `#::ns-alias{:c 3}`

|===

See:

* https://blog.jeaye.com/2017/10/31/clojure-keywords/[Jeaye's blog] for a refresher on namespaced keywords.
* https://clojure.atlassian.net/browse/CLJ-1910[CLJ-1910] for juicy details on namespaced maps.
* https://groups.google.com/g/clojure/c/i770QaIFiF0/m/v63cZgrlBwAJ[More modern terminology and some history from Alex Miller] - since rewrite-clj uses something akin to legacy terminology, we'll stick with that.


*ClojureScript Flavors* +
ClojureScript has two flavors for which I've not found definitive single terms. I'll use the following:

[cols="15%,85%"]
|===
| term | description

| _Regular ClojureScript_ | The regular old JVM compiled ClojureScript that most folks are familiar with.
| _Self-hosted ClojureScript_ | ClojureScript that is compiled by ClojureScript, also known as bootstrap ClojureScript.
Self-hosted ClojureScript can make runtime use of features that are only available at compile time in _Regular ClojureScript_.
Self-hosted ClojureScript behaves similarly more similarly to Clojure around namespaces.
|===

*Reader Conditionals* +
Clojure docs use multiple terms here. I'll stick to one.

[cols="15%,85%"]
|===
| term | description

| _Clojure platform_ | The `:clj`, `:cljs`, `:clr` or `:default` in a reader conditional.
It is referred to as a "feature" in other Clojure docs.

|===

==== Introduction

Rewrite-cljc can easily support `sexpr` on elements where the context is wholly contained in the form.
_Auto-resolved_ namespaced elements are different.
They depend on context outside of the form; namely the current namespace and namespace aliases.

We don't want to take on complex evaluation of Clojure code in rewrite-cljc to determine namespace info.
It will be up to the caller to specify the current namespace and namespace aliases.

We'll assume that callers will often have no real interest in an technically correct `sexpr` on _auto-resolved_ namespaced elements.
This means that we should still return a result and not throw if the namespace info is not provided/available.

We'll not work to preserve rewrite-clj compatibility for namespaced maps.
It was a late and incomplete addition to rewrite-clj.

==== General use of sexpr in rewrite-clj

Supporting `sexpr` is the most challenging aspect of supporting namespaced elements in rewrite-cljc.
Let's take a step back and look at `sexpr` in rewrite-clj in general.

The general idea was to make it easy to inspect and update nodes using familiar Clojure forms rather than having to deal with rewrite-clj nodes.

Rewrite-clj's `sexpr` is also used internally for automatic conversion from a rewrite-clj node to a Clojure form in functions like `find-value`, `find-next-value` and `edit` and some paredit functions inherited from rewrite-cljs.

The following throw an exception for `sexpr` which is sensible and is as-designed.

- comment
- whitespace
- uneval, which is rewrite-clj's term for `#_`

==== Support of namespaced elements in rewrite-clj and rewrite-cljs
_Auto-resolved_ keywords have been around https://groups.google.com/g/clojure/c/i770QaIFiF0/m/v63cZgrlBwAJ[since at least Clojure 1.0, which was released in May 2009].
https://github.com/clojure/clojure/blob/master/changes.md#12-support-for-working-with-maps-with-qualified-keys[Namespaced maps were introduce in Clojure 1.9, released in December 2017].
When you take into account that rewrite-clj was released in 2013 and rewrite-cljs in 2015, we can understand why support for newer features is spotty.

[cols="10%,10%,20%,20%,20%,20%"]
|===
2.2+h| element 2+h| rewrite-clj 2+h| rewrite-cljs
h|parse h|sexpr h|parse h|sexpr

1.3+|keyword | _qualified_ +
`:prefix/foo`
| supported
| supported
| supported
| supported

| _current&#8209;ns&nbsp;qualified_ +
`::foo`
| supported
| supported, +
*resolves via* `\*ns*`
| supported
| *throws*

| _alias-ns&nbsp;qualified_ +
`::alias/foo`
| supported
| *incorrectly returns* `:alias/foo` for `::alias/foo`
| supported
| *incorrectly returns* `:alias/foo` for `::alias/foo`

1.3+|map | _qualified_ +
`#:prefix{:a 1}`
| supported
| supported
| *somewhat supported with generic reader macro node*
a| *returns* `(read&#8209;string "#:prefix{:a&nbsp;1}")`

| _current&#8209;ns&nbsp;qualified_ +
`#::{:b 2}`
| *throws*
| *not applicable, +
can't parse*
| *throws*
| *not applicable, +
can't parse*

| _alias-ns&nbsp;qualified_ +
`#::alias{:c 3}`
| supported
a| supported, +
*resolves via* +
`(ns&#8209;aliases&nbsp;\*ns*)`
| *somewhat supported with generic reader macro node*
a| *returns* `(read&#8209;string "#::alias{:c&nbsp;3}")`

|===

==== Options for rewrite-cljc

[cols="15%,5%,40%,40%"]
|===
| status | ref |option | primary impact / notes

| rejected
| 1
| Do nothing
a| * both Clojure and ClojureScript users can't fully parse Clojure/ClojureScript code.

| rejected
| 2
a| Support parsing and writing, but throw on `sexpr`
a| * breaks existing API compatibility
* makes general navigation with certain rewrite-clj functions impossible

| candidate
| 3
a| Support parsing, writing. Have `sexpr` rely on user provided namespace info.
a| * seems like a good compromise

| candidate
| 4
a| Same as 3 but also ensure backward compatibility with current rewrite-clj implementation
a| * we'll see how awkward backward compatibility is for namespaced keywords
* we'll not entertain backward compatibility for namespaced maps

| rejected
| 5
a| Same as 4 but include a rudimentary namespace info resolver
a| * had a good chat with borkdude on Slack and concluded that a namespace info resolver:
** is a potential link:#sexpr-rabbit-hole[rabbit hole] (well, not potential - if only you knew the number of times I rewrote this section!)
** could be a separate concern that is addressed if there is a want/need in the future.

|===

My current thinking is to explore #4 and not entirely reject #3 if backward compatibility proves more onerous/awkward than it is worth.

[#sexpr-rabbit-hole]
.The Rabbit Hole - Automatically Calculating sexpr for Auto-resolved Elements
****
Parsing and writing namespaced elements seems relatively straightforward, but automatically returning a technically correct
`sexpr` for _auto-resolved_ namespaced elements is a rabbit hole that we'll reject for now.

Let's tumble down the hole a bit to look at some of the complexities that _auto-resolved_ namespaced elements include:

1. The `sexpr` of a _current-ns qualified_ element will be affected by the current namespace.
2. The `sexpr` of an _alias-ns qualified_ element will be affected by loaded namespaces aliases.
3. The `sexpr` of any namespace element can be affected by reader conditionals:

* within ns declarations
* surrounding the form being ``sexpr``ed which can be ambiguous in absence of parsing context of the _Clojure platform_

4. In turn, the current namespace can be affected by:

* `ns` declaration
* binding to `\*ns*`
* `in-ns`

5. Loaded namespace aliases can be affected by:

* `ns` declaration
* `require` outside `ns` declaration

6. I expect that macros can be used for generation of at least some of the above elements.

7. Other aspects I have not thought of.
****

==== Platform Support - Initial Review and Thoughts

===== Clojure
Rewrite-clj refers to `\*ns*` for namespaced elements and makes use  `(ns-aliases \*ns*)` for namespaced maps.

For _alias-ns qualified_ *maps*, this strongly implies that rewrite-clj expects, if the user wants a valid return from `sexpr`, that the source being parsed has been loaded and that `\*ns*` has been bound to appropriately.

Because rewrite-clj punted on _alias-ns qualified_ *keywords* and does not consult any namespace aliases, rewrite-clj only expects `\*ns*` to be bound to an equivalent namespace to code being parsed.
i.e. a namespace created via `create-ns` would do.

Forgetting about rewrite-clj inconsistencies and limitations, one could argue that binding `\*ns*` to the actual namespace of the code being parsed might be considered convenient for Clojure source that the caller trusts and is on the classpath.
It does not address Clojure source we might not trust and/or is not on the classpath.
Personally, I'm not a fan of this technique as it ties evaluation to parsing.

===== Self-Hosted ClojureScript
Because self-hosted ClojureScript has similar namespace support to Clojure, I think that whatever options make sense for Clojure will be applicable to self-hosted ClojureScript.

===== Regular ClojureScript
Regular ClojureScript lacks namespace support at runtime. Using `\*ns*` is questionable and `(ns-aliases \*ns*)` is not a viable option.

If we look elswhere for inspiration:

* link:https://clojure.github.io/tools.reader/#clojure.tools.reader/*alias-map*[clojure.tools.reader has an `\*ns-alias*` dynamic var]. We will likely adopt a similar approach.

* link:https://github.com/weavejester/cljfmt#configuration[Cljfmt has an `:alias-map` configuration option]. It can also parse `ns` declarations
from source code from which it extracts an alias map, a feature which is Clojure-client only right now, but I think only due to limitations
in rewrite-cljs. +
+
Cljfmt's technique of parsing `ns` declarations might work well for cljfmt, but for now, we consider this feature to be out of scope for rewrite-cljc
(see link:#sexpr-rabbit-hole[Rabbit Hole]).

===== Cljc & Reader Conditionals
Reader conditionals (introduced in Clojure 1.7 in June 2015) are commonly used in `ns` declarations.

Because we have opted out of supporting any kind of automatic parsing, we've also opted out of concerning ourselves with the effects of reader conditionals.

We'll also stop calling `(ns-aliases \*ns*)` for _alias-ns qualified_ maps to do away with its implications.

NOTE: On the off chance that I need to, I've distilled my understanding of distinguishing self-hosted cljs from regular cljs in a https://github.com/lread/demo-clj-variants[info repo].

==== Analysis for rewrite-cljc

===== Limitations

1. As discussed, we will do NO automatic resolving of namespace and namespace aliases
2. Specified namespace aliases will NOT deal with the possibility of different _Clojure platforms_ introduced by use of reader conditionals.
3. An `sexpr` will NOT evaluate differently if it is wrapped in a reader conditional

===== Integration
We will give the user some mechanism to explicitly specify the current namespace and namespace aliases.

Because `sexpr` is also used internally, and we are working with an legacy API, making rewrite-cljc aware of this data via a dynamic variable might be a sensible approach (as opposed to passing this via existing functions).

Technically the dynamic variable belongs to the parser namespace (I think?, implementation will tell me if that's true).
Let's call it `rewrite-cljc.parser/\*ctx*`.

Example data might be:

[source,Clojure]
----
{:ns 'name.of.ns
 :ns-aliases {'a1  'another.ns.a1
              'str 'clojure.string}}
----

Why don't we use make use of `\*ns*`?
Even though I'm thinking this would not be a great choice for _regular ClojureScript_ we still might want to remain backward compatible with rewrite-clj's _current-ns qualified_ keywords.
So we will support `\*ns*` as a fallback if `:ns` is not found in the context.

We will drop support for `(ns-aliases \*ns*)` for _ns-alias qualified_ maps.
This breaks behavior compatibility for the namespaced map support.
If a user wants to populate `:ns-aliases` using `(ns-aliases \*ns*)`, that's fine, but rewrite-cljc won't do so.

===== Backward Compatibility
When we talk about backward compatibility we are mostly talking about rewrite-clj (and not rewrite-cljs).
We are also talking about how we preserve rewrite-clj compatibility when running from ClojureScript.

I see 3 interesting aspects relating to backward behavior compatibility for rewrite-clj namespaced elements, `sexpr`:

[cols="10%,45%,45%"]
|===
| Breaking? | Rewrite-clj Behavior | Rewrite-cljc Behavior

| no
| makes use of `\*ns*` for _current-ns qualified_ keywords.
| we'll fall back to `\*ns*` if rewrite-cljc `\*ctx*` `:ns` not specified. See link:#sexpr-behavior[behavior section].

| no
| returns `:alias/foo` for _alias-ns qualified_ keyword `::alias/foo`
| we'll preserve https://github.com/xsc/rewrite-clj/issues/21#issuecomment-72071065[this odd behavior for keywords] if `\*ctx*` `:ns-aliases` was not specified.

| yes
| makes use of `(ns-aliases \*ns*)` for _ns-alias qualified_ maps.
| we'll break compatibility here and only support lookup of namespace aliases from rewrite-cljc `\*ctx*` `:ns&#8209;aliases`. +
Also: when `:ns-aliases` is not specified, we'll mimic the odd behavior for keywords.

|===

A more substantive breaking change is that we'll bring namespace map node support in under `map-node`.
This means that `namespaced-map-node` will be removed.

[#sexpr-behavior]
===== Behavior

My guess is that the majority of rewrite-cljc users will not make use of the `rewrite-cljc.parser/\*ctx*`, especially not `:ns-aliases` as there is no known easy way to correctly populate it.
None-the-less we will provide the possibility for those who might need it and a potential future solution.

[cols="20%,80%"]
|===
|Condition | Result


a| `\*ctx*` specifies `:ns`
a| *_Current-ns qualified_* element will use `:ns` value. +
[source,Clojure]
----
(binding [parser/*ctx* {:ns 'my-namespace}]
  (sexpr (parser/parse-string "::foo"))
  ;; => :my-namespace/foo
  (sexpr (parser/parse-string "#::{:a 1 :b 2}"))
  ;; => {:my-namepace/a 1 :my-namespace/b 2}
)
----

Specifying `:ns` via `\*ctx*` will be the recommended approach.
a| `\*ctx*` does not specify `:ns`
a| *_Current-ns qualified_* element will fallback to `ns-name` for `\*ns*` value, whatever it may be.
This fallback behavior is for backward compatibility with rewrite-clj namespaced keywords.
[source,Clojure]
----
(binding [*ns* (create-ns 'my-namespace)]
  (sexpr (parser/parse-string "::foo"))
  ;; => :my-namespace/foo
  (sexpr (parser/parse-string "#::{:a 1 :b 2}"))
  ;; => {:my-namepace/a 1 :my-namespace/b 2}
)
----

What happens when `\*ns*` is not specifically bound?

* In Clojure `\*ns*` points to the `user` namespace, so rewrite-cljc will pick that up:
+
[source,Clojure]
----
(sexpr (parser/parse-string "::foo"))
;; => :user/foo
(sexpr (parser/parse-string "#::{:a 1 :b 2}"))
;; => {:user/a 1 :user/b 2}
----

* In _regular ClojureScript_ `\*ns*` is `nil` at runtime, for consistency with Clojure, I think we'll pretend it is `user` when it is `nil`.

* In _self-hosted ClojureScript_ `\*ns*` takes on a more REPLy behavior. I've not tested extensively and only via planck, but it
seems to return the current namespace from `ns` declaration.

I'll add appropriate caveats in the docs. +
We'll recommend `rewrite-cljc.parser/\*ctx*` -> `:ns` over `\*ns*`.

a| `\*ctx*` specifies `:ns-alias` +
- alias found
a| For an *_alias-ns qualified_* element, we lookup alias in `:ns-aliases` in `\*ctx*`, when it is found:
[source,Clojure]
----
(binding [parser/*ctx* {:ns-aliases {'a1 'another.ns.a1
                                     'str 'clojure.string}]
  (sexpr (parser/parse-string "::str/foo"))
  ;; => :clojure.string/foo
  (sexpr (parser/parse-string "#::str{:a 1 :b 2}"))
  ;; => {:clojure.string/a 1 :clojure.string/b 2}
)
----

a| `\*ctx*` specifies `:ns-alias` +
- alias not found
a| For an *_alias-ns qualified_* element, when lookup of alias in specified `:ns-aliases` returns `nil`
one might expect we should throw. I think throwing is not a good idea. The user might not be specifically concerned
with the absolute correctness of this particular `sexpr` within the context of a larger operation that calls `sexpr` on many nodes.

Maybe we could express the not found namespace as `:_<?namespace-not-found?>_`:

[source,Clojure]
----
(binding [*ctx* {:ns-aliases {'a1 'another.ns.a1
                             'str 'clojure.string}]
  (sexpr (parser/parse-string "::nope/foo"))
  ;; => :_<?namespace-not-found?>_/foo
  (sexpr (parser/parse-string "#::nope{:a 1 :b 2}"))
  ;; => {:_<?namespace-not-found?>_/a 1 :_<?namespace?>_/b 2}
)
----

We might want to provide some mechanism for users to override this behavior. Maybe they'd like to throw instead.
Maybe they'd like to return a different value. But I think we can add in such support at a later
date if need be.

a| `\*ctx*` does not specify `:ns-alias` +
a| For *_alias-ns qualified_* element, when `:ns-aliases` has NOT been specified

Entirely for backward compatibility, we will mimic return of rewrite-clj _alias-ns qualified_ keywords:

[source,Clojure]
----
(sexpr (parser/parse-string "::nope/foo"))
;; => :nope/foo
(sexpr (parser/parse-string "#::nope{:a 1 :b 2}"))
;; => {:nope/a 1 :nope/b 2}
----

|===

==== Node Creation
The primary user of rewrite-clj's node creation functions is the rewrite-clj parser.
The functions are also exposed for general use.
General usability might not have been a focus.

===== Map Node
We are going to abandon rewrite-clj's namespaced map node creation function `namespaced-map-node`.
We'll instead add namespaced map node creation support under `map-node`.

Current signature is `(node/map-node children)` where `children` is converted to a `hash-map`.

To support namespaced maps, we'll add `(node/map-node qualify-type children)` where `qualify-type` will be one of:

* `{:type :unqualified}` - default (alternatively we could go with `nil` but I currently like the explicitness of a map).
* `{:type :literal :value "my-prefix"}`
* `{:type :ns-alias :value "my-alias"}`
* `{:type :current-ns`}

===== Keyword Node
The current way to create namespaced keyword nodes works, but usage is not entirely self-evident:
[source,clojure]
----
;; unqualified
(node/string (node/keyword-node :foo false))           ;; => ":foo"
;; literally qualified
(node/string (node/keyword-node :prefix-ns/foo false)) ;; => ":prefix-ns/foo"
;; current-ns qualified
(node/string (node/keyword-node :foo true))            ;; => "::foo"
;; alias-ns qualified
(node/string (node/keyword-node :ns-alias/foo true))   ;; => "::ns-alias/foo"
----

Use of booleans in a function signature with more than one argument rarely contributes to readability.
We'll need to preserve these functions for backward compatibility.

We'll consider adding the more user friendly and map-node consistent:

* `(node/keyword-node2 keyword)`
* `(node/keyword-node2 qualify-type keyword)`

==== Node Traversal

==== maps
A map node will remain 1 node:

* children (the map)

But will now have a queryable `qualify-type`

==== keywords

A keyword node will remain unchanged for backward compatibility.

We'll add a queryable `qualify-type` for consistency with maps.

==== Node interogation

* `map-node?` - returns true if rewrite-cljc node is map node
* `keyword-node?` - return true if rewrite-cljc node is keyword node
* `qualify-type` - on `keyword-node` and `map-node`
* `qualified?` - might be a nice convenience for `keyword-node` and `map-node`

==== Coercion
Rewrite-clj supports automatic coercion, how does this look in the context of namespaced elements?

If we try to explicitly coerce a namespaced element, we must remember that the Clojure reader will first evaluate in the
context of the current ns before the element is converted to a node.

[source,clojure]
----
(require '[clojure.string :as string])
(-> (node/coerce :user/foo) node/string) ;; => ":user/foo"
(-> (node/coerce ::foo) node/string) ;; => ":user/foo"
(-> (node/coerce ::str/foo) node/string) ;; => ":clojure.string/foo"
----

For namespaced maps, the experience is the same:

[source,clojure]
----
(require '[clojure.string :as string])
(-> (node/coerce #:user{:a 1}) node/string) ;; => "{:user/a 1}"
(-> (node/coerce ::{:b 2}) node/string)  ;; => "{:user/b 2}"
(-> (node/coerce ::str{:c 3}) node/string) ;; => "{:clojure.string/c 3}"
----

==== Misc Questions
Questions I had while writing section.

*Q:* Does the act of using find-value sometimes blow up if hitting an element that is not sexpressable? +
*A:* Nope, find-value only searches token nodes and token nodes are always sexpressable (well after we are done our work they should be).
