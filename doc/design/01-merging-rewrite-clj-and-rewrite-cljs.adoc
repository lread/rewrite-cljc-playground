= Merging rewrite-clj and rewrite-cljs
:toc:
:toclevels: 6

== Introduction
rewrite-cljc is a merge of https://github.com/xsc/rewrite-clj[rewrite-clj] and https://github.com/clj-commons/rewrite-cljs[rewrite-cljs] giving us a one stop rewrite-cljc shop for Clojure and ClojureScript developers.

== Goals
1. *Minimize API breakage*. Within reason, maintain API compatability with both rewrite-clj and rewrite-cljs. I'd like rewrite-cljc to be an low friction replacement for `rundis/rewrite-cljs` (actually now living at `clj-commons/rewrite-cljs`) and `xsc/rewrite-clj`.
2. *Feature parity*. rewrite-cljs has lagged behind rewrite-cljc. Bring rewrite-cljs up to parity with rewrite-cljc. Bring any rewrite-cljs specific features over to rewrite-cljc.
3. *Preserve type hints*. I will respect and carry over existing type hinting in rewrite-clj and rewrite-cljs. I will not, at this time, evaluate if existing type hinting has value.
4. *Improve documentation*. I think that rewrite-clj documentation is good, but as I dig deeper into using the library and get feedback on Slack, I see places where guidance could be improved.
5. *Document design decisions*. I'm not sure what form this will take, but I do like projects that include histories of architectural and design decisions. Perhaps I'll adopt https://github.com/cljdoc/cljdoc/tree/master/doc/adr[adr ala cljdoc]. For now you can think of this document as I kind of sloppy-mega adr for my merge work.
6. *Modernize/update test/build*. Look at what is available today and make a choice.
7. *Define library version scheme*. Evaluate options, pick one and document.
8. *Find home for this work*. Ideally, I think this work would be merged into `xsc/rewrite-clj`, but if that does not work out, a reasonable alternative might be `clj-commons/rewrite-cljc` (which would be a replacement for a deprecated `clj-commons\rewrite-cljs`)

== Strategic Compromises
1. *Favor single code base*. I will favor a single code base over maintaining  http://rundis.github.io/blog/2015/clojurescript_performance_tuning.html[ClojureScript specific optimizations from rewrite-cljs]. These can be brought in at a later date if needed.
2. *Use generic exceptions*.  This is technically an API breakage, but I will switch to using the Clojure/ClojureScript agnostic `ex-info` for exceptions.
3. *Favor rewrite-clj features when there is overlap*. I currently only see one feature that overlaps between the two projects. rewrite-clj and rewrite-cljs both have positional (row/col) support. Base positional support in rewrite-clj is full featured and updates with any changes made, so we'll use it instead of rewrite-cljs's more primitive tools reader based positional support. This technically constitutes an API breakage for rewrite-cljs. We will, though, carry over rewrite-cljs's higher level positional functions.

== Changes
=== Breaking
. Root namespace is `rewrite-cljc` instead of `rewrite-clj`
. Minimum versions
** Clojure v1.9
** Java v1.8
** ClojureScript v10
. Now using `ex-info` for exceptions
. Base positional support for rewrite-cljs has been migrated over to rewrite-clj implementation

=== Potentially breaking
1. Switched to `clojure.tools.reader.edn`
2. Potential performance hit for rewrite-cljs. Some rewrite-cljs specific optimizations dropped in favor of single code base.

=== Neutral
1. Docs now generated by cljdoc
** direct zipper functions (`right*`, `left*`, `up*`, etc) now show correct arguments.
** ``import-var``ed protocol functions now point to correct source code
** now using asciidoc
** now using markdown in docstrings
2. Continuous integration is now handled by circleci
3. Test tooling now uses:
** figwheel main for development cljs testing
** kaocha for clj testing
4. Switched from leiningen to tools cli `deps.edn`

=== Accretive

From what I perceive as public APIs, rewrite-clj has gained:

[cols="2,3"]
|===
| public | description

| rewrite-cljc.paredit
| structured editing of S-expression data formerly in rewrite-cljs only

| rewrite-cljc.zip/append-child*
| formerly internal only and omitted, I assume, by accident

| rewrite-cljc.zip/find-last-by-pos
| positional search support formerly in rewrite-cljs only

| rewrite-cljc.zip/find-tag-by-pos
| positional search support formerly in rewrite-cljs only

| rewrite-cljc.zip/insert-newline-left
| formerly internal only and omitted, I assume, by accident

| rewrite-cljc.zip/insert-newline-right
| formerly omitted, I assume, by accident

| rewrite-cljc.zip/insert-space-left
| formerly internal only and omitted, I assume, by accident

| rewrite-cljc.zip/insert-space-right
| formerly internal only and omitted, I assume, by accident

| rewrite-cljc.zip/position-span
| positional search support formerly in rewrite-cljs only

| rewrite-cljc.zip/remove-preserve-newline
| formerly in rewrite-cljs only

| rewrite-cljc.zip/subzip
| formerly internal only, found useful to expose
|===

And rewrite-cljs has gained all of rewrite-clj's features except for the ability to read from files.

=== Detailed API diffs

I've used https://github.com/lread/diff-apis[diff-apis] to compare apis.
Normally I would have excluded any apis tagged with `:no-doc` metadata, but
because many folks used undocumented features in rewrite-clj and rewrite-cljs, I
have done a complete comparison of all publics - except where noted . Each
report contains some observations under the "Notes" header.

* link:../generated/api-diffs/rewrite-clj-and-rewrite-cljs.adoc[rewrite-clj vs rewrite-cljs] API differences between the projects on which rewrite-cljc is based.
* link:../generated/api-diffs/rewrite-clj-and-rewrite-cljc-clj.adoc[rewrite-clj vs rewrite-cljc] how different is rewrite-cljc from rewrite-clj?
* link:../generated/api-diffs/rewrite-cljs-and-rewrite-cljc-cljs.adoc[rewrite-cljs vs rewrite-cljc] how different is rewrite-cljc from rewrite-cljs?
* link:../generated/api-diffs/rewrite-cljc.adoc[rewrite-cljc] a look at how cljs and clj sides of rewrite-cljc differ
* link:../generated/api-diffs/rewrite-cljc-documented-only.adoc[rewrite-cljc documented apis only] a look at how cljs and clj sides of rewrite-cljc differ for documented apis.

=== Feature Differences
No ability to read from files when using rewrite-cljc from ClojureScript.

== Root namespace of `rewrite-cljc`

Both rewrite-clj and rewite-cljs share the same root namespace of `rewrite-clj`.

I decided against reusing the same root namespace for rewrite-cljc. It will have
`rewrite-cljc` as its root namespace.

Rationale:

* Ideally rewrite-cljc work would have been merged into the current rewrite-clj
repo, but that did not work out, so rewrite-cljc will have different maven
coordinates than rewrite-clj, most likely `clj-commons/rewrite-cljc`.

* Having to update namespace `:require` references from `rewrite-clj` to `rewrite-cljc`
in one's project sources to upgrade to rewrite-cljc is much less of a burden than
the burden of the confusion of introducing colliding namespaces to the Clojure
community.
+
Colliding namespaces would likely first confuse, then require exclusions -
a deps.edn example:
+
[source,clojure]
----
{olical/depot {:mvn/version "1.8.4" :exclusions [rewrite-clj/rewrite-clj]}}
----

* A different root namespace means upgrading to rewrite-cljc will be a
clear and deliberate choice.

== Observations
=== Wow, a lot of libraries use rewrite-clj
During this work, I noticed how pervasive rewrite-clj usage is. Some prominent examples:

. https://github.com/bhauman/figwheel-main[figwheel-main] which uses https://github.com/bhauman/rebel-readline[rebel-readline] which uses rewrite-clj
. https://github.com/Olical/depot[depot] uses rewrite-clj
. https://github.com/clojure-emacs/cider[cider] which can optionally enable https://github.com/clojure-emacs/clj-refactor.el[clj-refactor] which brings in rewrite-clj
. https://github.com/cognitect-labs/REBL-distro[REBL] which uses cljfmt which uses rewrite-clj

== Tooling

=== Build tools
I have moved from leiningen to tools cli and `deps.edn`. Like everything, this change has pros and cons. Overall, I like the simplicity and control it brings. Bash scripts take the place of lein aliases where I can have the build do exactly what I want it to. One current, but likely temporary, downside is the jar and deploy support for tools cli is fragmented with many young libraries. I have opted, for now to employ the tried and true maven for jar and deploy.

=== Continuous integration
The future of https://travis-ci.org/[Travis CI] looked a bit tenuous when I started this work, so I switched over to https://circleci.com/[CircleCI].

=== Testing and linting tools
After looking around, I settled on the following for continuous integration:

. https://github.com/lambdaisland/kaocha[Kaocha] for running Clojure unit tests.
. moved from lein-doo to https://github.com/Olical/cljs-test-runner[cljs-test-runner] (which still uses https://github.com/bensu/doo[doo] under the hood) for running ClojureScript unit tests under node and chrome headless. I considered Koacha's cljs support and will reconsider when it matures a bit.
. I fail the build when a lint with https://github.com/borkdude/clj-kondo[clj-kondo] produces any warnings and/or errors.

During development, I found the following helpful:

. kaocha in watch mode for Clojure
. figwheel main for ClojureScript

== General Decisions

=== * Library version scheme - [red]*in progress*
I see plenty of version scheme variations out there these days. Here are a few examples I find interesting:

[cols="10,40,20,~",options="header"]
|====
|Project
|Scheme
|Example
|Observation

|https://github.com/clojure/clojurescript/releases[ClojureScript]
|major.minor.<commit count since major.minor>
|`1.10.520`
|Tracks Clojure version.

|https://github.com/borkdude/clj-kondo/releases[clj-kondo]
|yyyy-mm-dd-qualifier
|`2019.07.05-alpha`
|Freshness built into version.

|https://github.com/cljdoc/cljdoc[cljdoc]
|major.minor.<commit count>-<short git sha>
|`0.0.1315-c9e9a73`
|The short-sha safeguards against any potential confusion with duplicate commit counts for builds on different machines.

|https://github.com/noprompt/meander[meander]
|meander/<release> 0.0.<commit count>
|`meander/delta` `0.0.137`
|This scheme changes the artifact-id (for example gamma to delta) every time a potentially breaking change is introduced effectively releasing a new product for every breaking change.

|https://github.com/clojure/spec.alpha[spec.alpha]
|unimportant
|unimportant
|The alpha state is burnt into the project name and library namespace.
|====

rewrite-clj is not a new project. I feel the version should reflect at least some familiarity with its current scheme.

As of this writing the current version of rewrite-clj is `0.6.1`. I am guessing that the 0 is an unused version element, and we have a `0.major.minor` scheme.

rewrite-cljc is going to switch to a ClojureScript-ish scheme. +
It will use a `major.minor.<commit count since major.minor>-<qualifier>` scheme. +
Our first version will be `1.0.42-alpha` where `42` is just a wild guess right now.

=== * Release Strategy - [red]*in progress*

TODO: think about the following...

We'll opt not to make SNAPSHOT releases and assume the community is good with testing pre-releases via
github coordinates. That said, I suppose opting out of SNAPSHOT releases means option out of testing
our release flow on successful pushes.

Our releases notes will be managed under GitHub releases.  I'll have a look at how @borkdude does this for his
various projects.

Not sure about release cadence yet. I expect to cut a release when I feel a pre-release has been tested enough.

TODO: Consider some sort of canary testing for a set of projects that make use of rewrite-clj. Examples that
come to mind: cljfmt, zprint, carve.

=== Source directory layout
When I first started to experiment with a cljc version of rewrite-clj, my directory layout looked like:

----
src/
  clj/
    rewrite-cljc/
  cljs/
    rewrite-cljc/
  cljc/
    rewrite-cljc/
test/
  clj/
    rewrite-cljc/
  cljs/
    rewrite-cljc/
  cljc/
    rewrite-cljc/
----

After a certain amount of work, I realized the majority of the code was cljc so opted for the much simpler:

----
src/
  rewrite-cljc/
test/
  rewrite-cljc/
----

=== * Graalvm support - [red]*in progress*

Some command line tools written in Clojure are using Graal to compile to native
executables for fast startup times.

Others have done the work to test that rewrite-clj can be compiled with Graal.
There is benefit to the community to test that rewrite-cljc can also be compiled
to native code with Graal.

Noticing that there were differing approaches Graalifying Clojure, none of them centrally
documented, @borkdude and I created https://github.com/lread/clj-graal-docs[clj-graal-docs]
to develop and share scripts and tips.

My goal is to run the rewrite-cljc test suite from a graalvm native image to
give some confidence that rewrite-cljc works after compiled with Graal.

==== Technical approach

1. reference Clojure v1.10.2-alpha1 which includes fixes for Graal (notably CLJ-1472)
2. generate a test-runner in Clojure that explicitly references and runs all my tests
3. aot compile the test-runner (aot compilation automatically compiles all referenced source)
4. compile the aot compiled test-runner to native binary with Graal
5. run test-runner binary

==== Issues

GraalVM's native-image command needs a significant amount of RAM to compile rewrite-cljc tests in a reasonable amount of time, and still a significant amount of RAM to run at all. A few ad hoc tests on a 3.5 GHz Quad-Core i7 iMac with "-J-Xmx" at:

* 16g ~3 minutes
* 8g ~11 minutes
* 4g - failed with java.lang.OutOfMemoryError: Java heap space after ~1 hour

This means running these tests in one swoop on the free tier of CircleCI, which has a limit of 4gb, is not currently an option.

GitHub Actions offers 7gb of RAM, but that is still not enough to run tests in one swoop.

Drone Cloud, a service with a very generous 64gb of RAM available, has no problem handling these
tests. Unfortunately it is Linux only so would not offer multi-platform verification.

==== Options
[cols="5%,5%,15%,30%,25%,25%"]
|===
| Ref | Status | Option | Description | Pros | Cons

| 1
| candidate
| Drone Cloud Only
| Run tests on Drone Cloud only
a| * Easiest
* Tests and source are natively compiled
a| * Linux only
* Drone Cloud seems a bit obscure?
* Solves problem of running tests, but not general problem of running on constrained CI service (does not help community)

| 2
| experimentation paused
| Split tests into multiple runs
| Split tests into sets where each set can run under RAM constraints of CI service. Would involve figuring
which how to break up tests. Would likely use GitHub Actions because it is more generous with available RAM.
a| * Tests and source are natively compiled
a| * Long running local process to figure out test split
* Natively compiling multiple sets makes for more work during CI

| 3
| rejected
| Wait for GraalVM to reduce RAM usage
| The Graal team is working to reduce the memory footprint of `native-image` sometime in the v20.x version.
a| * Ideally would allow us to run on any popular free tier CI service
a| * Might wait a looong time!
* Might never happen

| 4
| rejected
| Command line test harness
| Create a command line test harness, compile it to native-image, then run tests from the command line.

This approach is a natural fit for command line tools and has been employed successfully by @borkdude for clj-kondo.
a|* Reduces memory footprint of native-image
a|* Overhead of creating and maintaining a command line test harness

| 5
| candidate
| bb-rewrite-cljc
| This idea is from @borkdude.

Fork https://github.com/borkdude/babashka[babashka], include rewrite-cljc src (but not tests) then build a custom bb-rewrite-cljc.

Interpret rewrite-cljc tests with bb-rewrite-cljc.

To reduce memory footprint further could disable all optional babashka features.

Note that CircleCI bumped up RAM on CircleCI at @borkdude's request so this
idea would likely be executed on the more RAM generous GitHub Actions.

a| * TBD, but will reduce memory footprint of native-image
a| * Complexity of figuring out bb-rewrite-cljc

| 6
| experimenting
| sci-rewrite-cljc
| Another idea from the always helpful @borkdude.

Use babashka's intepreter, https://github.com/borkdude/sci[sci], to run tests. Same concept as bb-rewrite-cljc but leaner.

This would be creating a native-image from sci + any test libraries I need + test runner support + rewrite-cljc sources,
then interpreting rewrite-cljc tests use sci-rewrite-cljc

a| * TBD, but will reduce memory footprint of native-image
* Might be able to come up with something that is useful to community
a| * Complexity of figuring out sci-rewrite-cljc

|===

Thinking about the above options has helped me to understand what we want to test: we want to verify that our library's public
API function as expected when natively compiled by Graal. We don't necessarily need to test internal mechanisms.

One of rewrite-cljc's internal mechanisms is its version of import-vars, for which it has tests.
These tests need not be exercised under Graal to prove that the public API functions under Graal.

== Questionable Decisions

=== Allowing garden style keywords

Borkdude is kind enough to ping me when there are issues with the internally
forked version of rewrite-clj he uses for clj-kondo. It turns out that
clojure.tools.reader.edn does not parse https://github.com/noprompt/garden[garden-style]
keywords such as `:&::before`. The reader sees a double colon as illegal if it is anywhere in the keyword.
Borkdude overcame this limitation by allowing a keyword to contain embedded
double colons via a customized version of ``clojure.tools.reader.edn``'s
`read-keyword` function.

I transcribed his work to rewrite-cljc.

The maintenance cost to hacking a 3rd party lib is that upgrades will have to be
carefully tracked. That said, we do have a good suite of tests that should
uncover any issues.

=== Not allowing symbols with multiple slashes

While clojure reads `'org/clojure/math.numeric-tower`, `clojure.tools.reader.edn`
barfs on this and therefore rewrite-cljc does as well.

It has been documented as illegal for a symbol to have more than one `/`.

I have opted to not, at this time, adapt rewrite-cljc to allow parsing of this
illegal syntax. This might seem a bit hypocritical because I did, some time ago, innocently
https://github.com/borkdude/clj-kondo/issues/378[raise an issue on clj-kondo for
this].

== Clojure/ClojureScript Issues

=== ClojureScript namespace clashes
ClojureScript uses Google Closure under the hood. Because of the way Google Closure handles namespaces, some namespaces that work fine on Clojure clash under ClojureScript. Some rewrite-clj namespaces clash for ClojureScript, for example:

* `rewrite-clj.zip/find`
* `rewrite-clj.zip.find`

The original rewrite-cljs author worked around this problem by renaming namespaces to avoid the clashes.

[%autowidth]
|===

.2+h|library .2+h|namespace 3+h|in rewrite-cljc
h|namespace h|clj? h|cljs?

|rewrite-clj
|rewrite-clj.node.coerce
|rewrite-cljc.node.coerce
|yes
|no

|rewrite-cljs
|rewrite-clj.node.coerce[yellow-background]**r**
|rewrite-cljc.node.coercer
|yes
|yes

|rewrite-clj
|rewrite-clj.node.string
|rewrite-cljc.node.string
|yes
|no

|rewrite-cljs
|rewrite-clj.node.string[yellow-background]**z**
|rewrite-cljc.node.stringz
|yes
|yes

|rewrite-clj
|rewrite-clj.zip.edit
|rewrite-cljc.zip.edit
|yes
|no

|rewrite-cljs
|rewrite-clj.zip.edit[yellow-background]**z**
|rewrite-cljc.zip.editz
|yes
|yes

|rewrite-clj
|rewrite-clj.zip.find
|rewrite-cljc.zip.find
|yes
|no

|rewrite-cljs
|rewrite-clj.zip.find[yellow-background]**z**
|rewrite-cljc.zip.findz
|yes
|yes

|rewrite-clj
|rewrite-clj.zip.remove
|rewrite-cljc.zip.remove
|yes
|no

|rewrite-cljs
|rewrite-clj.zip.remove[yellow-background]**z**
|rewrite-cljc.zip.removez
|yes
|yes

|rewrite-clj
|rewrite-clj.zip.seq
|rewrite-cljc.zip.seq
|yes
|no

|rewrite-cljs
|rewrite-clj.zip.seq[yellow-background]**z**
|rewrite-cljc.zip.seqz
|yes
|yes
|===

None of these namespaces are part of public APIs, but because I see a lot of
code that uses these internal namespaces, I decided to preserve the existing
rewrite-clj and rewrite-cljs naming for rewrite-cljc.

=== Clojure/ClojureScript interop

* Where I felt I could get away with it, I localized Clojure/ClojureScript differences in the `rewrite-cljc.interop` namespace.
* Although technically an API breakage, I made a choice to switch all rewrite-cljc thrown exceptions to the Clojure/ClojureScript compatible ex-info.
* Some notes on differences between Clojure and ClojureScript
** throws and catches, if not using ex-info are different
** namespace requires cannot use shorthand syntax in cljs
** macros must (sometimes) be included differently
** IMetaData and other base types different
** format not part of cljs standard lib
** no Character in cljs
** no ratios in cljs
** testing for NaN is different
** different max numerics


== rewrite-clj/cljs Analysis

=== What is the public API?
rewrite-clj purposefully only generated documentation for specific namespaces. It is reasonable to assume that these namespaces represent the public API.

* `rewrite-clj.parse`
* `rewrite-clj.node`
* `rewrite-clj.zip`

I am not sure why `rewrite-clj.custom-zipper` is included in the documented public API, because its functionality is exposed through `rewrite-clj.zip`, I expect this was perhaps an oversight, but might be wrong.

Because what is public versus what is private was not stressed strongly in the
rewrite-clj README, I frequently see private APIs used in code. For this reason,
I've worked, within reason, not to break what I understand to be private APIs.

=== S-expressions
rewrite-clj allows parsed Clojure/ClojureScript/EDN to be converted back and forth to s-expressions.  Example from a REPL session:

[source,clojure]
----
user=> (require '[rewrite-cljc.zip :as z])
nil
user=> (def zipper (z/of-string "[1 2 3]"))  // <1>
#'user/zipper
user=> zipper
[<vector: [1 2 3]> {:l [], :pnodes [<forms: [1 2 3]>], :ppath nil, :r nil}]
user=> (def s (z/sexpr zipper)) // <2>
#'user/s
user=> s
[1 2 3]
user=> (require '[rewrite-cljc.node :as n])
nil
user=> (n/coerce s) // <3>
<vector: [1 2 3]>
----
<1> parse string to rewrite-clj nodes and create zipper
<2> convert rewrite-clj node at current location in zipper to s-expression
<3> convert s-expression to rewrite-clj node

While I expect this can be quite convenient, it does come with caveats:

1. What happens when we try to `sexpr` Clojure specific features from ClojureScript? For example, ratios are available in Clojure but not ClojureScript.
2. If you try to `sexpr` something that cannot be converted into an s-epxression an exception will be thrown.

My guidance is use `sexpr` in only in specific cases, where you know ahead of time what you are parsing. General blind use of `sexpr` is not recommended.

For rewrite-cljc itself, I have removed internal problematic uses of `sepxr`.

=== Which reader?
rewrite-clj makes use of Clojure's reader.  There are a few choices though:

1. `clojure.tools.reader`
2. `clojure.tools.reader.edn`
3. `clojure.reader`
4. `clojure/reader-string`

As I understand it, `clojure.tools.reader.edn` is the safest choice and I have updated rewrite-cljc to use it in all cases.


=== Potemkin import-vars
rewrite-clj makes use of a slightly modified version of https://github.com/ztellman/potemkin#import-vars[Potemkin import-vars]. The intent of import-vars is to make it easy to expose a public API from a set of internal namespaces.

When I first reviewed its usage in rewrite-clj, I found import-vars to be quite elegant. I have since learned that there is quite a bit of strong opinion in the Clojure community surrounding import-vars. Not all of it is rosy.

Also, there is no ClojureScript version of import-vars.

That said, I decided, at least for now, to honor the original rewrite-clj
codebase and carry on with it. To be honest, this gave me the (the apparently
too tempting to resist) opportunity to learn how to write a version of
import-vars for ClojureScript. This led me to discover that while cljdoc did
cope fine with import-vars trickery for Clojure code, it did not have any
support for it for ClojureScript code. I made the necessary changes to cljdoc's
fork of codox and subsequently cljdoc-analyzer. When Martin Klepsch finds the
time, he will integrate my pull request.

I also extended import-vars to rewrite-clj's purposes by adding a facility to
rename imported vars and adapt docstrings.

All is not entirely rainbows and unicorns yet,

. I am not certain, but I think import-vars might not play well with https://github.com/cloverage/cloverage[cloverage]. I gave it a quick try and it failed miserably. My first suspect is import-vars.
. Linters can report false posistives
.. https://github.com/candid82/joker[joker] has no concept of import-vars
.. https://github.com/borkdude/clj-kondo[clj-kondo] does understand import-vars - but not my customized version that handles transformations of symbols.

=== Positional support
rewrite-clj

1. added a custom zipper to optionally track row/col within Clojure/ClojureScript/EDN files.
2. expresses positions as a `[row-number col-number]` vector.

rewrite-cljs

1. made use of the positional support provided by Clojure tools reader.
2. exposed a couple of functions to search by position.
3. expressed positions as a `{:row row-number :col col-number}` map

Because the positional support in rewrite-clj tracks row/col even after zipper modifications, we use it instead of rewrite-cljs's implementation.
We:

1. continue to support both rewrite-clj vector rewrite-cljs map notations for positions on function parameters.
2. use vector notation for position on function returns. I personally prefer the map notation, but, as a rule, favor rewrite-clj over rewrite-cljs because rewrite-clj is the more widely used library and thus changes affect more users.
3. include rewrite-cljs's positional functions: `rewrite-cljc.zip/find-last-by-pos` and `rewrite-cljc.zip/find-tag-by-pos` .

The most glaring breaking change for ClojureScript is that it must now create the zipper with positional support enabled, for example: `(z/of-string "[1 2 3]" {:track-position true})`

=== * Namespaced maps - [red]*in progress*

At the time of this writing, rewrite-clj had released partial support for
namespaced maps. I attempted to complete this support in a pull request which
was never merged into rewrite-cljc.

As part of this merge I decided to include full namespaced map support which meant:

1. including a refined version of my rewrite-clj pull request
2. adding namespaced maps support for ClojureScript

[NOTE]
====
Refresher on namespaced maps:
[source, clojure]
----
#:prefix-ns{:a 1}  // <1>
#::ns-alias{:b 2}  // <2>
#::{:c 3}          // <3>
----
<1> `prefix-ns` is applied directly to map keys
<2> `ns-alias` is a valid namespace alias that is applied to map keys
<3> current namespace is applied to map keys

Namespace is only applied to direct children. +
You might find the examples in https://clojure.atlassian.net/browse/CLJ-1910[CLJ-1910] helpful.
====

The rewrite-clj namespaced map support tried to resolve namespaces. Resolution is really only necessary for `sexpr` and I have adjusted the code accordingly.

TODO: I'm not sure resolution is necessary for prefix and alias resolve namespace maps at all. If we assume we are not in job of validating source code, we
can simply apply the prefix-ns or the ns-alias to the keys.

TODO: Where things get interesting is the auto-resolve namespace. It resolves to the current namespace. Would some tooling want to `sexpr` an auto-resolve namespaced map, but not want to bother with binding the current *ns*? I am thinking maybe?
