= Namespaced elements
:toc:
:toclevels: 6

Herein we study what rewrite-clj and rewrite-cljs currently do for namespaced elements and explore our options for rewrite-cljc.

You will a focus on `sepxr` in this document. It is the primary challenge in supporting namespaced elements.

== Nomenclature

*Namespaced Elements* +
Clojure docs describe namespaced elements but I did not see clear terms defined.
Alex Miller helped out on Slack, I will use:

|===
| term | my shorthand | keyword example | map example

| _unqualified_
|
a| `:foo`
a| `{:x 10}`
| _qualified_ +

 |
a| `:prefix-ns/foo`
a| `#:prefix-ns{:a 1}`

| _auto-resolved current namespace qualified_
| _current-ns qualified_
a| `::foo`
a| `#::{:b 2}`

| _auto-resolved namespace alias qualified_
| _ns-alias qualified_
a| `::ns-alias/foo`
a| `#::ns-alias{:c 3}`

|===

See:

* https://blog.jeaye.com/2017/10/31/clojure-keywords/[Jeaye's blog] for a refresher on namespaced keywords.
* https://clojure.atlassian.net/browse/CLJ-1910[CLJ-1910] for details on namespaced maps.
* https://groups.google.com/g/clojure/c/i770QaIFiF0/m/v63cZgrlBwAJ[Terminology and some history from Alex Miller]


*ClojureScript Flavors* +
ClojureScript has two flavors for which I've not found definitive unique terms. I'll use the following:

[cols="15%,85%"]
|===
| term | description

| _Regular ClojureScript_ | The regular old JVM compiled ClojureScript that most folks are familiar with.
| _Self-hosted ClojureScript_ | ClojureScript that is compiled by ClojureScript, also known as bootstrap ClojureScript.
Self-hosted ClojureScript can make runtime use of features that are only available at compile time in _Regular ClojureScript_.
Self-hosted ClojureScript behaves similarly to Clojure around namespaces.
|===

== What happens now in rewrite-clj and rewrite-cljs?

=== General use of sexpr in rewrite-clj
The `sexpr` function is used to convert a rewrite-clj node to a Clojure form.
Clojure forms are more familiar and can be easier to work with than rewrite-clj nodes.

Rewrite-clj's `sexpr` is also used internally in functions like `find-value`, `find-next-value` and `edit` and some paredit functions inherited from rewrite-cljs.

The following rewrite-clj nodes throw an exception for `sexpr` which is sensible and is as-designed.

- comment
- whitespace
- uneval, which is rewrite-clj's term for `#_`

=== Sexpr support for namespaced elements in rewrite-clj and rewrite-cljs
_Auto-resolved_ keywords have been around https://groups.google.com/g/clojure/c/i770QaIFiF0/m/v63cZgrlBwAJ[since at least Clojure 1.0, which was released in May 2009].
https://github.com/clojure/clojure/blob/master/changes.md#12-support-for-working-with-maps-with-qualified-keys[Namespaced maps were introduce in Clojure 1.9, released in December 2017].
When you take into account that rewrite-clj was released in 2013 and rewrite-cljs in 2015, we can understand why support for newer features is spotty.

[cols="10%,10%,20%,20%,20%,20%"]
|===
2.2+h| element 2+h| rewrite-clj 2+h| rewrite-cljs
h|parse h|sexpr h|parse h|sexpr

1.3+|keyword | _qualified_ +
`:prefix/foo`
| supported
| supported
| supported
| supported

| _current&#8209;ns&nbsp;qualified_ +
`::foo`
| supported
| supported, +
⚠️ *resolves via* `\*ns*`
| supported
| ⚠️ *throws*

| _ns-alias&nbsp;qualified_ +
`::alias/foo`
| supported
| ⚠️ *incorrectly returns* `:alias/foo` for `::alias/foo`
| supported
| ⚠️ *incorrectly returns* `:alias/foo` for `::alias/foo`

1.3+|map | _qualified_ +
`#:prefix{:a 1}`
| supported
| supported
| ⚠️ *somewhat supported with generic reader macro node*
a| ⚠️ *returns* `(read&#8209;string "#:prefix{:a&nbsp;1}")`

| _current&#8209;ns&nbsp;qualified_ +
`#::{:b 2}`
| ⚠️ *throws*
| ⚠️ *not applicable, +
can't parse*
| ⚠️ *throws*
| ⚠️ *not applicable, +
can't parse*

| _ns-alias&nbsp;qualified_ +
`#::alias{:c 3}`
| supported
a| ⚠️ awkwardly supported, +
*resolves via* +
`(ns&#8209;aliases&nbsp;\*ns*)`
| ⚠️ *somewhat supported with generic reader macro node*
a| ⚠️ *returns* `(read&#8209;string "#::alias{:c&nbsp;3}")`

|===

== Options for rewrite-cljc

[cols="15%,5%,40%,40%"]
|===
| status | ref |option | primary impact / notes

| ❌ rejected
| 1
| Do nothing
a| * both Clojure and ClojureScript users can't fully parse Clojure/ClojureScript code.

| ❌ rejected
| 2
a| Support parsing and writing, but throw on `sexpr`
a| * breaks existing API compatibility
* makes general navigation with certain rewrite-clj functions impossible

| ✅ candidate
| 3
a| Support parsing, writing. Have `sexpr` rely on user provided namespace info.
a| * seems like a good compromise

| ✅ candidate
| 4
a| Same as 3 but also ensure backward compatibility with current rewrite-clj implementation
a| * we'll see how awkward backward compatibility is for namespaced keywords
* we'll not entertain backward compatibility for namespaced maps

| ❌ rejected
| 5
a| Same as 4 but include a rudimentary namespace info resolver
a| * had a good chat with borkdude on Slack and concluded that a namespace info resolver:
** is a potential link:#sexpr-rabbit-hole[rabbit hole] (well, not potential - if only you knew the number of times I rewrote this section!)
** could be a separate concern that is addressed if there is a want/need in the future.

|===

My current thinking is to explore #4 and not entirely reject #3 if backward compatibility proves more onerous/awkward than it is worth.

[#sexpr-rabbit-hole]
.The Rabbit Hole - Automatically Calculating sexpr for Auto-resolved Elements
****
Parsing and writing namespaced elements seems relatively straightforward, but automatically parsing and returning a technically correct `sexpr` for _auto-resolved_ namespaced elements is a rabbit hole that we'll reject for now.

Let's tumble down the hole a bit to look at some of the complexities that _auto-resolved_ namespaced elements include:

1. The `sexpr` of a _current-ns qualified_ element will be affected by the current namespace.
2. The `sexpr` of an _ns-alias qualified_ element will be affected by loaded namespaces aliases.
3. The `sexpr` of any namespace element can be affected by reader conditionals:

* within ns declarations
* surrounding the form being ``sexpr``ed which can be ambiguous in absence of parsing context of the _Clojure platform_ (clj, cljs, clr, sci)

4. In turn, the current namespace can be affected by:

* `ns` declaration
* binding to `\*ns*`
* `in-ns`

5. Loaded namespace aliases can be affected by:

* `ns` declaration
* `require` outside `ns` declaration

6. I expect that macros can be used for generation of at least some of the above elements.

7. Other aspects I have not thought of.

I see one example from the wild of an attempt to parse `ns` declarations from Clojure in cljfmt.
Cljfmt can parse `ns` declarations from source code from which it extracts an alias map.
While parsing `ns` declarations might work well for cljfmt, we won't entertain it for rewrite-cljc.

****

== What will we do for rewrite-cljc?

Rewrite-cljc can easily support `sexpr` on elements where the context is wholly contained in the form.
_Auto-resolved_ namespaced elements are different.
They depend on context outside of the form; namely the current namespace and namespace aliases.

Rewrite-cljc will:

* NOT take on evaluation of the Clojure code it is parsing to determine namespace info.
It will be up to the caller to optionally specify the current namespace and namespace aliases.

* NOT offer any support for reader conditionals around caller provided namespace info
** caller specified namespace info will not distinguish for _Clojure platforms_ (clj, cljs, clr, sci)
** an `sexpr` for a namespaced element will NOT evaluate differently if it is wrapped in a reader conditional

* assume that callers will often have no real interest in an technically correct `sexpr` on _auto-resolved_ namespaced elements.
This means that it will return a result and not throw if the namespace info is not provided/available.

* break rewrite-clj compatibility for namespaced maps.
It was a late and incomplete addition to rewrite-clj.
** We will drop `namespaced-map-node` and instead move support into `map-node`.
** Unlike rewrite-clj, rewrite-cljc will not call `(ns-aliases \*ns*)` to lookup namespace aliases.

* break compatibility for `sexpr` on some namespaced elements, in that it will:
** no longer throw for formerly unsupported variants
** have the possibility of returning a more correct Clojure form

* preserve compatibility for `sexpr` under the following questionable scenarios, we'll:
** fall back to `\*ns*` if the current namespace is not specified by caller.
** return `:alias/foo` for _ns-alias qualified_ keyword `::alias/foo` when namespace aliases are not specified by caller

=== Platform Support

Rewrite-cljc supports the following Clojure platforms:

* Clojure
* _Self-Hosted ColojureScript_
* _Regular ClojureScript_

It also supports Clojure source that includes a mix of the above in `.cljc` files.

Our solution will cover all the above and also be verified when running rewrite-cljc under sci.

[#sexpr-behavior]
=== Sexpr Behaviour

The caller will convey namespace info via `rewrite-cljc.parser/\*ctx*` dynamic variable (final namespace and name TBD during implementation).

Example value:

[source,Clojure]
----
{:ns 'name.of.ns
 :ns-aliases {'a1  'another.ns.a1
              'str 'clojure.string}}
----

A namespace can be a symbol, string or of namespace type.
Aliases can be strings or symbols.

For backward compatibility, we will support `\*ns*` as a fallback if `:ns` is not provided in `\*ctx*`.

If a caller wants to populate `:ns-aliases` using `(ns-aliases \*ns*)`, that's fine, but rewrite-cljc won't do so.

My guess is that the majority of rewrite-cljc users will not make use of the `rewrite-cljc.parser/\*ctx*`.
This is likely to be especially true of `:ns-aliases` as there is no known easy way to correctly populate them.
None-the-less we will provide the possibility for those who might want/need it.

[cols="20%,80%"]
|===
|Condition | Result


a| `\*ctx*` specifies `:ns`
a| *_Current-ns qualified_* elements will use `:ns` value. +
[source,Clojure]
----
(binding [parser/*ctx* {:ns 'my-namespace}]
  (sexpr (parser/parse-string "::foo"))
  ;; => :my-namespace/foo
  (sexpr (parser/parse-string "#::{:a 1 :b 2}"))
  ;; => {:my-namepace/a 1 :my-namespace/b 2}
)
----

Specifying `:ns` via `\*ctx*` will be the recommended approach.
a| `\*ctx*` does not specify `:ns`
a| *_Current-ns qualified_* element will fallback to `\*ns*` value, whatever it may be.
This fallback behavior is for backward compatibility with rewrite-clj namespaced keywords.
[source,Clojure]
----
(binding [*ns* (create-ns 'my-namespace)]
  (sexpr (parser/parse-string "::foo"))
  ;; => :my-namespace/foo
  (sexpr (parser/parse-string "#::{:a 1 :b 2}"))
  ;; => {:my-namepace/a 1 :my-namespace/b 2}
)
----

What happens when `\*ns*` is not specifically bound?

* In Clojure `\*ns*` points to the `user` namespace, so rewrite-cljc will pick that up:
+
[source,Clojure]
----
(sexpr (parser/parse-string "::foo"))
;; => :user/foo
(sexpr (parser/parse-string "#::{:a 1 :b 2}"))
;; => {:user/a 1 :user/b 2}
----

* In _regular ClojureScript_ `\*ns*` is `nil` at runtime, for consistency with Clojure, I think we'll pretend it is `user` when it is `nil`.

* In _self-hosted ClojureScript_ `\*ns*` takes on a more REPLy behavior. I've not tested extensively and only via planck, but it
seems to return the current namespace from `ns` declaration.

I'll add appropriate caveats in the docs. +
We'll recommend `rewrite-cljc.parser/\*ctx*` -> `:ns` over `\*ns*`.

a| `\*ctx*` specifies `:ns-alias` +
- alias found
a| For an *_ns-alias qualified_* element, we lookup alias in `:ns-aliases` in `\*ctx*`, when it is found:
[source,Clojure]
----
(binding [parser/*ctx* {:ns-aliases {'a1 'another.ns.a1
                                     'str 'clojure.string}]
  (sexpr (parser/parse-string "::str/foo"))
  ;; => :clojure.string/foo
  (sexpr (parser/parse-string "#::str{:a 1 :b 2}"))
  ;; => {:clojure.string/a 1 :clojure.string/b 2}
)
----

a| `\*ctx*` specifies `:ns-alias` +
- alias not found
a| For an *_ns-alias qualified_* element, when lookup of alias in specified `:ns-aliases` returns `nil`
one might expect we should throw. I think throwing is not a good idea. The user might not be specifically concerned
with the absolute correctness of this particular `sexpr` within the context of a larger operation that calls `sexpr` on many nodes.

Maybe we could express the not found namespace as `:_<?namespace-not-found?>_`:

[source,Clojure]
----
(binding [*ctx* {:ns-aliases {'a1 'another.ns.a1
                             'str 'clojure.string}]
  (sexpr (parser/parse-string "::nope/foo"))
  ;; => :_<?namespace-not-found?>_/foo
  (sexpr (parser/parse-string "#::nope{:a 1 :b 2}"))
  ;; => {:_<?namespace-not-found?>_/a 1 :_<?namespace?>_/b 2}
)
----

We might want to provide some mechanism for users to override this behavior. Maybe they'd like to throw instead.
Maybe they'd like to return a different value. But I think we can add in such support at a later
date if need be.

Alternative: we could behave the same here as when `:ns-alias` is not specified.
See next behaviour.

a| `\*ctx*` does not specify `:ns-alias` +
a| For *_ns-alias qualified_* element, when `:ns-aliases` has NOT been specified

Entirely for namespaced keyword backward compatibility, we will mimic return of rewrite-clj _ns-alias qualified_ keywords:

[source,Clojure]
----
(sexpr (parser/parse-string "::nope/foo"))
;; => :nope/foo
(sexpr (parser/parse-string "#::nope{:a 1 :b 2}"))
;; => {:nope/a 1 :nope/b 2}
----

|===

=== Node Creation
The primary user of rewrite-clj's node creation functions is the rewrite-clj parser.
The functions are also exposed for general use.
General usability might not have been a focus.

==== Map Node
We abandon rewrite-clj's namespaced map node creation function `namespaced-map-node`.
We'll instead add namespaced map node creation support under `map-node`.

Current signature is `(node/map-node children)` where `children` is converted to a `hash-map`.

To support namespaced maps, we'll add `(node/map-node children opts)`.

Usages:

* `(node/map-node children)` - unqualified map.
* `(node/map-node children {:auto-resolved? false :prefix "my-prefix"})` - qualified map
* `(node/map-node children {:auto-resolved? true})` - current-ns qualified map
* `(node/map-node children {:auto-resolved? true  :prefix "my-alias"})` - ns-alias qualified map

The `MapNode` record will include `auto-resolved?` and `prefix` fields.
For an unqualified map these fields will be nil.

==== Keyword Node
The current way to create namespaced keyword nodes works, but usage is not entirely self-evident:
[source,clojure]
----
;; unqualified
(node/keyword-node :foo false)           ;; => ":foo"
;; literally qualified
(node/keyword-node :prefix-ns/foo false) ;; => ":prefix-ns/foo"
;; current-ns qualified
(node/keyword-node :foo true)            ;; => "::foo"
;; ns-alias qualified
(node/keyword-node :ns-alias/foo true)   ;; => "::ns-alias/foo"
----

Use of booleans in a function signature with more than one argument rarely contributes to readability but we'll stick with these functions for backward compatibility.

Let's study the rewrite-clj `KeywordNode` which currently has fields `k` and `namespaced?`.

[source,clojure]
----
(require '[rewrite-clj.parser :as p]
         '[rewrite-clj.node :as n])

(-> (p/parse-string ":kw") ((juxt :k :namespaced?)))
;; => [:kw nil]
(-> (p/parse-string ":qual/kw") ((juxt :k :namespaced?)))
;; => [:qual/kw nil]
(-> (p/parse-string "::kw") ((juxt :k :namespaced?)))
;; => [:kw true]
(-> (p/parse-string "::alias/kw") ((juxt :k :namespaced?)))
;; => [:alias/kw true]
----

* The `namespaced?` field is, in my opinion, misnamed and should be `auto-resolved?`.
Ideally I would deprecate `namespaced?` and add synonym `auto-resolved?`, but is that even possible?
As of this writing https://grep.app/search?q=%3Anamespaced%3F[a grep.app for :namespaced?] returns only clj-kondo and it uses its own custom version of rewrite-clj.
I think I could get away with renaming `namespaced?` to `auto-resolved?`
* The `prefix` is not stored separately, it is glommed into keyword field `k`.
** This is ok for `:qual/kw` but, in my opinion, awkward for auto-resolved variants.
** We'll preserve this storage behavior for backward compatibility.
I will not look into adding a `prefix` field for consistency with maps for the first release.

=== Node Traversal

Both keyword and map nodes traversal will remain unchanged (no new child nodes).

=== Node Interogation

* `map-node?` - returns true if rewrite-cljc node is map node
* `keyword-node?` - return true if rewrite-cljc node is keyword node
* Both `keyword-node` and `map-node` will have:
** `auto-resolved?` field
** `qualified?` fn - returns true if the element is qualified
* `map-node` will have:
** `prefix` field

=== Notes on Coercion
Rewrite-clj supports automatic coercion, how does this look in the context of namespaced elements?

If we try to explicitly coerce a namespaced element, we must remember that the Clojure reader will first evaluate in the context of the current ns before the element is converted to a node.

[source,clojure]
----
(require '[clojure.string :as string])
(-> (node/coerce :user/foo) node/string) ;; => ":user/foo"
(-> (node/coerce ::foo) node/string) ;; => ":user/foo"
(-> (node/coerce ::str/foo) node/string) ;; => ":clojure.string/foo"
----

For namespaced maps, the experience is the same:

[source,clojure]
----
(require '[clojure.string :as string])
(-> (node/coerce #:user{:a 1}) node/string) ;; => "{:user/a 1}"
(-> (node/coerce ::{:b 2}) node/string)  ;; => "{:user/b 2}"
(-> (node/coerce ::str{:c 3}) node/string) ;; => "{:clojure.string/c 3}"
----

== Misc Questions
Questions I had while writing doc.

*Q:* Does the act of using find-value sometimes blow up if hitting an element that is not sexpressable? +
*A:* Nope, find-value only searches token nodes and token nodes are always sexpressable (well after we are done our work they should be).
