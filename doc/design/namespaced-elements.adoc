= Namespaced elements
:toc:
:toclevels: 6

Herein we study what rewrite-clj and rewrite-cljs currently do for namespaced elements and explore our options for rewrite-cljc.

You will see a focus on `sepxr` in this document; it is the primary challenge in supporting namespaced elements.

== Nomenclature

*Namespaced Elements* +
Clojure docs describe namespaced elements but I did not see clear terms defined.
Alex Miller helped out on Slack, I will use:

|===
| term | my shorthand | keyword example | map example

| _unqualified_
|
a| `:foo`
a| `{:x 10}`
| _qualified_ +

 |
a| `:prefix-ns/foo`
a| `#:prefix-ns{:a 1}`

| _auto-resolved current namespace qualified_
| _current-ns qualified_
a| `::foo`
a| `#::{:b 2}`

| _auto-resolved namespace alias qualified_
| _ns-alias qualified_
a| `::ns-alias/foo`
a| `#::ns-alias{:c 3}`

|===

See:

* https://blog.jeaye.com/2017/10/31/clojure-keywords/[Jeaye's blog] for a refresher on namespaced keywords.
* https://clojure.atlassian.net/browse/CLJ-1910[CLJ-1910] for details on namespaced maps.
* https://groups.google.com/g/clojure/c/i770QaIFiF0/m/v63cZgrlBwAJ[Terminology and some history from Alex Miller]


Because the nuances of namespaced maps are not widely known by even the most experienced Clojure developers, I'll paste a subset of CLJ-1910 examples here.
The `_` prefix and the fact that namespaced maps qualify symbols in addition to keywords is not widely understood.

[source, Clojure]
----
;; same as above - notice you can nest #: maps and this is a case where the printer roundtrips
user=> #:person{:first "Han" :last "Solo" :ship #:ship{:name "Millenium Falcon" :model "YT-1300f light freighter"}}
#:person{:first "Han" :last "Solo" :ship #:ship{:name "Millenium Falcon" :model "YT-1300f light freighter"}}

;; effects on keywords with ns, without ns, with _ ns, and non-kw
user=> #:foo{:kw 1, :n/kw 2, :_/bare 3, 0 4}
{:foo/kw 1, :n/kw 2, :bare 3, 0 4}

;; auto-resolved namespaces (will use the current namespace, in this case, user as the ns)
user=> #::{:kw 1, :n/kw 2, :_/bare 3, 0 4}
:user/kw 1, :n/kw 2, :bare 3, 0 4}

;; auto-resolve alias s to clojure.string
user=> (require '[clojure.string :as s])
nil
user=> #::s{:kw 1, :n/kw 2, :_/bare 3, 0 4}
{:clojure.string/kw 1, :n/kw 2, :bare 3, 0 4}

;; to show symbol changes, we'll quote the whole thing to avoid evaluation
user=> '#::{a 1, n/b 2, _/c 3}
{user/a 1, n/b 2, c 3}
----

*ClojureScript Flavors* +
ClojureScript has two flavors for which I've not found definitive unique terms. I'll use the following:

[cols="15%,85%"]
|===
| term | description

| _Regular ClojureScript_ | The regular old JVM compiled ClojureScript that most folks are familiar with.
| _Self-hosted ClojureScript_ | ClojureScript that is compiled by ClojureScript, also known as bootstrap ClojureScript.
Self-hosted ClojureScript can make runtime use of features that are only available at compile time in _Regular ClojureScript_.
Self-hosted ClojureScript behaves similarly to Clojure around namespaces.
|===

== What happens now in rewrite-clj and rewrite-cljs?

=== General use of sexpr in rewrite-clj
The `sexpr` function is used to convert a rewrite-clj node to a Clojure form.
Clojure forms are more familiar and can be easier to work with than rewrite-clj nodes.

Rewrite-clj's `sexpr` is also used internally in functions like `find-value`, `find-next-value` and `edit` and some paredit functions inherited from rewrite-cljs.

The following rewrite-clj nodes throw an exception for `sexpr` which is sensible and is as-designed.

- comment
- whitespace
- uneval, which is rewrite-clj's term for `#_`

=== Sexpr support for namespaced elements in rewrite-clj and rewrite-cljs
_Auto-resolved_ keywords have been around https://groups.google.com/g/clojure/c/i770QaIFiF0/m/v63cZgrlBwAJ[since at least Clojure 1.0, which was released in May 2009].
https://github.com/clojure/clojure/blob/master/changes.md#12-support-for-working-with-maps-with-qualified-keys[Namespaced maps were introduce in Clojure 1.9, released in December 2017].
When you take into account that rewrite-clj was released in 2013 and rewrite-cljs in 2015, we can understand why support for newer features is spotty.

[cols="10%,10%,20%,20%,20%,20%"]
|===
2.2+h| element 2+h| rewrite-clj 2+h| rewrite-cljs
h|parse h|sexpr h|parse h|sexpr

1.3+|keyword | _qualified_ +
`:prefix/foo`
| supported
| supported
| supported
| supported

| _current&#8209;ns&nbsp;qualified_ +
`::foo`
| supported
| supported, +
⚠️ *resolves via* `\*ns*`
| supported
| ⚠️ *throws*

| _ns-alias&nbsp;qualified_ +
`::alias/foo`
| supported
| ⚠️ *incorrectly returns* `:alias/foo` for `::alias/foo`
| supported
| ⚠️ *incorrectly returns* `:alias/foo` for `::alias/foo`

1.3+|map | _qualified_ +
`#:prefix{:a 1}`
| supported
| supported
| ⚠️ *somewhat supported with generic reader macro node*
a| ⚠️ *returns* `(read&#8209;string "#:prefix{:a&nbsp;1}")`

| _current&#8209;ns&nbsp;qualified_ +
`#::{:b 2}`
| ⚠️ *throws*
| ⚠️ *not applicable, +
can't parse*
| ⚠️ *throws*
| ⚠️ *not applicable, +
can't parse*

| _ns-alias&nbsp;qualified_ +
`#::alias{:c 3}`
| supported
a| ⚠️ awkwardly supported, +
*resolves via* +
`(ns&#8209;aliases&nbsp;\*ns*)`
| ⚠️ *somewhat supported with generic reader macro node*
a| ⚠️ *returns* `(read&#8209;string "#::alias{:c&nbsp;3}")`

|===

== Options for rewrite-cljc

[cols="15%,5%,40%,40%"]
|===
| status | ref |option | primary impact / notes

| ❌ rejected
| 1
| Do nothing
a| * both Clojure and ClojureScript users can't fully parse Clojure/ClojureScript code.

| ❌ rejected
| 2
a| Support parsing and writing, but throw on `sexpr`
a| * breaks existing API compatibility
* makes general navigation with certain rewrite-clj functions impossible

| ✅ current choice
| 3
a| Support parsing, writing. Have `sexpr` rely on user provided namespace info.
a| * seems like a good compromise

| ❌ rejected
| 4
a| Same as 3 but also ensure backward compatibility with current rewrite-clj implementation
a| * we'll see how awkward backward compatibility is for namespaced keywords
* we'll not entertain backward compatibility for namespaced maps

| ❌ rejected
| 5
a| Same as 4 but include a rudimentary namespace info resolver
a| * had a good chat with borkdude on Slack and concluded that a namespace info resolver:
** is a potential link:#sexpr-rabbit-hole[rabbit hole] (well, not potential - if only you knew the number of times I rewrote this section!)
** could be a separate concern that is addressed if there is a want/need in the future.

|===

Option #4 was a candidate, but decided against maintaining/explaining the complexity the current rewrite-clj implementation.

[#sexpr-rabbit-hole]
=== The Rabbit Hole - Automatically Calculating sexpr for Auto-resolved Elements
****
Parsing and writing namespaced elements seems relatively straightforward, but automatically parsing and returning a technically correct `sexpr` for _auto-resolved_ namespaced elements is a rabbit hole that we'll reject for now.

Let's tumble down the hole a bit to look at some of the complexities that _auto-resolved_ namespaced elements include:

1. The `sexpr` of a _current-ns qualified_ element will be affected by the current namespace.
2. The `sexpr` of an _ns-alias qualified_ element will be affected by loaded namespaces aliases.
3. The `sexpr` of any namespace element can be affected by reader conditionals:

* within ns declarations
* surrounding the form being ``sexpr``ed which can be ambiguous in absence of parsing context of the _Clojure platform_ (clj, cljs, clr, sci)

4. In turn, the current namespace can be affected by:

* `ns` declaration
* binding to `\*ns*`
* `in-ns`

5. Loaded namespace aliases can be affected by:

* `ns` declaration
* `require` outside `ns` declaration

6. I expect that macros can be used for generation of at least some of the above elements.

7. Other aspects I have not thought of.

I see one example from the wild of an attempt to parse `ns` declarations from Clojure in cljfmt.
Cljfmt can parse `ns` declarations from source code from which it extracts an alias map.
While parsing `ns` declarations might work well for cljfmt, we won't entertain it for rewrite-cljc.

****

== What will we do for rewrite-cljc?

Rewrite-cljc can easily support `sexpr` on elements where the context is wholly contained in the form.
_Auto-resolved_ namespaced elements are different.
They depend on context outside of the form; namely the current namespace and namespace aliases.

Rewrite-cljc will:

* NOT take on evaluation of the Clojure code it is parsing to determine namespace info.
It will be up to the caller to optionally specify the current namespace and namespace aliases.

* NOT offer any support for reader conditionals around caller provided namespace info
** caller specified namespace info will not distinguish for _Clojure platforms_ (clj, cljs, clr, sci)
** an `sexpr` for a namespaced element will NOT evaluate differently if it is wrapped in a reader conditional

* assume that callers will often have no real interest in an technically correct `sexpr` on _auto-resolved_ namespaced elements.
This means that it will return a result and not throw if the namespace info is not provided/available.

* break rewrite-clj compatibility for namespaced maps.
It was a late and incomplete addition to rewrite-clj.
** We will drop `namespaced-map-node` and instead move support into `map-node`.
** Unlike rewrite-clj, rewrite-cljc will not call `(ns-aliases \*ns*)` to lookup namespace aliases.

* break compatibility for `sexpr` on some namespaced elements, in that it will:
** no longer throw for formerly unsupported variants
** have the possibility of returning a more correct Clojure form

* NOT preserve compatibility for `sexpr` under the following questionable scenarios, we'll:
** NOT fall back to `\*ns*` if the current namespace is not specified by caller.
** NOT return `:alias/foo` for _ns-alias qualified_ keyword `::alias/foo` when namespace aliases are not specified by caller

* forgetting about `sexpr`, whatever implementation we choose, rewrite-cljc must continue to emit the same code as parsed .
This should return `true` for any source we throw at rewrite-cljc:
+
[source,Clojure]
----
(def source (slurp "https://raw.githubusercontent.com/borkdude/clj-kondo/master/src/pod/borkdude/clj_kondo.clj"))
(= source (-> source z/of-string z/root-string))
----
+
Note: an exception might me newlines, which rewrite-cljc might normalize.

=== Platform Support

Rewrite-cljc supports the following Clojure platforms:

* Clojure
* _Self-Hosted ColojureScript_
* _Regular ClojureScript_

It also supports Clojure source that includes a mix of the above in `.cljc` files.

Our solution will cover all the above and also be verified when GraalVM natively compiled rewrite-cljc and a rewrite-cljc exposed via sci.

[#sexpr-behavior]
=== Sexpr Behaviour

The caller will optionally convey a namespace `:auto-resolve` function in `opts` map argument.

The `:auto-resolve` function will take a single `alias` lookup arg, `alias` will be:
- `:current` for a request for the current namespace
- otherwise a request for a lookup for namespaced aliased by `alias`

If not specified, `:auto-resolve` will default a function that resolves:
- the current namespace to `user`
- an aliased namespaced `x` to `x-unresolved`

The optionally `opts` arg will be added to the existing `(rewrite-cljc/node/sexpr node)`

If a caller wants their `:auto-resolve` function to make use of `\*ns*` and/or `(ns-aliases \*ns*)` that's fine, but unlike rewrite-clj, rewrite-cljc will not reference `\*ns*`.

My guess is that the majority of rewrite-cljc users will not make use of `:auto-resolve`.

[cols="20%,80%"]
|===
|Condition | Result


a| `:auto-resolve` not specified
a|
[source,Clojure]
----
(-> (parser/parse-string "::foo") node/sexpr)
;; => :user/foo
(-> (parser/parse-string "#::{:a 1 :b 2}") node/sexpr)
;; => {:user/a 1 :user/b 2}
(-> (parser/parse-string "::str/foo") node/sexpr)
;; => :str-unresolved/foo
(-> (parser/parse-string "#::str{:a 1 :b 2}") node/sexpr)
;; => {:str-unresolved/a 1 :str-unresolved/b 2}


a| `:auto-resolve` specified
a|
[source,Clojure]
----
(def opts {:auto-resolve (fn [alias]
                            (get {:current my.current.ns
                                  'str 'clojure.string}
                                 alias
                                 (symbol (str alias "-unresolved"))))})

(-> (parser/parse-string "::foo") (node/sexpr opts))
;; => :my.current.ns/foo
(-> (parser/parse-string "#::{:a 1 :b 2}") (node/sexpr opts))
;; => {:my.current.ns/a 1 :my.current.ns/b 2}
(-> (parser/parse-string "::str/foo") (node/sexpr opts))
;; => :clojure.string/foo
(-> (parser/parse-string "#::str{:a 1 :b 2}") (node/sexpr opts))
;; => {:clojure.string/a 1 :clojure.string/b 2}
----
|===

A benefit of `:auto-resolve` being a function rather than data, is flexibility.
Maybe a caller would like the resolver to throw on an unresolved alias.
Callers are free to code up whatever they need.

=== Sexpr on a Key in a Namespaced Map

To support `sexpr` when navigating down to a key in a namespaced map, the key will hold the namespaced map context, namely a copy of the namespaced map qualifier.

This context will appropriately applied to symbols and keyword keys in namespaced maps:

* at parse time
* when node children are updated

The zip API applies updates when moving up through the zipper.
The update includes replacing children.
Therefore the context will be reapplied to namespaced map keys when moving up through the zipper.

We'll provide some mechanism for zipper users to reapply the context throughout the zipper.
This will remove context from any keywords and symbols that are no longer under a namespaced map.

Not sure what we'll provide for non-zipper users.
Perhaps just exposing a clear-map-context for keywords and symbols would suffice.

=== Sexpr Behaviour from the zip API

The `rewrite-cljc.zip` API exposes functions that make use of `sexpr`:

- `sexpr` - directly exposes `rewrite-cljc.node/sexpr` for the current node in zipper
- `find-value` - uses `sexpr` internally
- `find-next-value` - uses `sexpr` internally
- `edit-node` - uses `sexpr` internally
- `get` - uses `find-value` internally

Most of these functions lend themselves to adding an optional `opts` map for our `:auto-resolve`.
Unfortunately `edit-node` is variadic.

Because all zip API functions operate on the zipper, I'm thinking that we could simply hold the `:auto-resolve` in the zipper.

This idea is already in play to for `:track-position?`.

=== Node Creation
The primary user of rewrite-clj's node creation functions is the rewrite-clj parser.
The functions are also exposed for general use.
General usability might not have been a focus.

==== Map Node
Map node creation remains as is.

==== Namespaced Map Node

We tweak rewrite-clj's `namespaced-map-node`.

The children will remain:

* prefix
* optional whitespace
* map

The prefix will now be encoded as a new `map-qualifier-node` node which will have `auto-resolved?` and `prefix` fields.
This cleanly and explicitly adds support for auto-resolve current-ns namespaced maps which will be expressed with `auto-resolved?` as `true` and a `nil` `prefix`.

==== Keyword Node
The current way to create namespaced keyword nodes works, but usage is not entirely self-evident:
[source,clojure]
----
;; unqualified
(node/keyword-node :foo false)           ;; => ":foo"
;; literally qualified
(node/keyword-node :prefix-ns/foo false) ;; => ":prefix-ns/foo"
;; current-ns qualified
(node/keyword-node :foo true)            ;; => "::foo"
;; ns-alias qualified
(node/keyword-node :ns-alias/foo true)   ;; => "::ns-alias/foo"
----

Use of booleans in a function signature with more than one argument rarely contributes to readability but we'll stick with these functions for backward compatibility.

Let's study the rewrite-clj `KeywordNode` which currently has fields `k` and `namespaced?`.

[source,clojure]
----
(require '[rewrite-clj.parser :as p]
         '[rewrite-clj.node :as n])

(-> (p/parse-string ":kw") ((juxt :k :namespaced?)))
;; => [:kw nil]
(-> (p/parse-string ":qual/kw") ((juxt :k :namespaced?)))
;; => [:qual/kw nil]
(-> (p/parse-string "::kw") ((juxt :k :namespaced?)))
;; => [:kw true]
(-> (p/parse-string "::alias/kw") ((juxt :k :namespaced?)))
;; => [:alias/kw true]
----

* The `namespaced?` field is, in my opinion, misnamed and should be `auto-resolved?`.
As of this writing https://grep.app/search?q=%3Anamespaced%3F[a grep.app for :namespaced?] returns only clj-kondo and it uses its own custom version of rewrite-clj.
I think I could get away with renaming `namespaced?` to `auto-resolved?`
* The `prefix` is not stored separately, it is glommed into keyword field `k`.
** This is ok for `:qual/kw` but, in my opinion, awkward for auto-resolved variants.
** We'll preserve this storage behavior for backward compatibility.
I will NOT look into adding a `prefix` field for consistency with maps for the first release.

==== Symbol Node
We'll separate out a new SymbolNode out from under TokenNode.

It is probably simplest to have the existing `token-node` creator fn simply create a SymbolNode when passed value is a Clojure symbol.

==== Symbol and Keyword Context

The SymbolNode and KeywordNode will be MapQualifiable.
This means they will have `(set-map-context map-qualifier-node)` and `(clear-map-context)` functions.

I don't think we need to expose the methods to our APIs but am not sure yet.

=== Node Traversal

Keyword node traversal will remain unchanged (no new child nodes).

Map node traversal remains the same.
The prefix is now stored as a `map-qualifier-node`, in rewrite-clj the prefix was encoded in a keyword.

=== Node Interogation

* `map-node?` - returns true if rewrite-cljc node and map node
* `keyword-node?` - return true if rewrite-cljc node and keyword node
* `symbol-node?` - return true if rewrite-cljc node and symbol node
* Both `keyword-node` and `map-qualifier-node` will have:
** `auto-resolved?` field
** `qualified?` fn - returns true if the element is qualified
* `map-node` will have:
** `prefix` field

=== Notes on Coercion
Rewrite-clj supports automatic coercion, how does this look in the context of namespaced elements?
I'm not proposing any changes here, just exploring how things work.

If we try to explicitly coerce a namespaced element, we must remember that the Clojure reader will first evaluate in the context of the current ns before the element is converted to a node.

[source,clojure]
----
(require '[clojure.string :as string])
(-> (node/coerce :user/foo) node/string) ;; => ":user/foo"
(-> (node/coerce ::foo) node/string) ;; => ":user/foo"
(-> (node/coerce ::str/foo) node/string) ;; => ":clojure.string/foo"
----

For namespaced maps, the experience is the same:

[source,clojure]
----
(require '[clojure.string :as string])
(-> (node/coerce #:user{:a 1}) node/string) ;; => "{:user/a 1}"
(-> (node/coerce ::{:b 2}) node/string)  ;; => "{:user/b 2}"
(-> (node/coerce ::str{:c 3}) node/string) ;; => "{:clojure.string/c 3}"
----

== Misc Questions
Questions I had while writing doc.

*Q:* Does the act of using find-value sometimes blow up if hitting an element that is not sexpressable? +
*A:* Nope, find-value only searches token nodes and token nodes are always sexpressable (well after we are done our work they should be).
